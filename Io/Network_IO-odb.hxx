// This file was generated by ODB, object-relational mapping (ORM)
// compiler for C++.
//

#ifndef INPUT_CONTEXT_ODB_HXX
#define INPUT_CONTEXT_ODB_HXX

#include <odb/version.hxx>

#if (ODB_VERSION != 20100UL)
#error ODB runtime version mismatch
#endif

#include <odb/pre.hxx>

#include "Network_IO.h"

#include <memory>
#include <cstddef>

#include <odb/core.hxx>
#include <odb/traits.hxx>
#include <odb/callback.hxx>
#include <odb/wrapper-traits.hxx>
#include <odb/pointer-traits.hxx>
#include <odb/tr1/wrapper-traits.hxx>
#include <odb/tr1/pointer-traits.hxx>
#include <odb/container-traits.hxx>
#include <odb/cache-traits.hxx>
#include <odb/result.hxx>
#include <odb/simple-object-result.hxx>

#include <odb/details/buffer.hxx>
#include <odb/details/unused.hxx>

#include <odb/sqlite/version.hxx>
#include <odb/sqlite/forward.hxx>
#include <odb/sqlite/binding.hxx>
#include <odb/sqlite/sqlite-types.hxx>
#include <odb/sqlite/query.hxx>

namespace odb
{
  // timing_phase
  //
  template <>
  struct class_traits< ::pio::timing_phase >
  {
    static const class_kind kind = class_composite;
  };

  template <>
  class access::composite_value_traits< ::pio::timing_phase >
  {
    public:
    typedef ::pio::timing_phase value_type;

    struct image_type
    {
      // phase
      //
      long long phase_value;
      bool phase_null;

      // barrier
      //
      long long barrier_value;
      bool barrier_null;

      // ring
      //
      long long ring_value;
      bool ring_null;

      // position
      //
      long long position_value;
      bool position_null;

      // minimum
      //
      long long minimum_value;
      bool minimum_null;

      // maximum
      //
      long long maximum_value;
      bool maximum_null;

      // extend
      //
      long long extend_value;
      bool extend_null;

      // yellow
      //
      long long yellow_value;
      bool yellow_null;

      // red
      //
      long long red_value;
      bool red_null;
    };

    static bool
    grow (image_type&, bool*);

    static void
    bind (sqlite::bind*, image_type&, sqlite::statement_kind);

    static bool
    init (image_type&, const value_type&, sqlite::statement_kind);

    static void
    init (value_type&, const image_type&, database*);

    static bool
    get_null (const image_type&);

    static void
    set_null (image_type&, sqlite::statement_kind);
  };

  // shape_geometry
  //
  template <>
  struct class_traits< ::pio::shape_geometry >
  {
    static const class_kind kind = class_composite;
  };

  template <>
  class access::composite_value_traits< ::pio::shape_geometry >
  {
    public:
    typedef ::pio::shape_geometry value_type;

    struct image_type
    {
      // x
      //
      double x_value;
      bool x_null;

      // y
      //
      double y_value;
      bool y_null;

      // z
      //
      double z_value;
      bool z_null;
    };

    static bool
    grow (image_type&, bool*);

    static void
    bind (sqlite::bind*, image_type&, sqlite::statement_kind);

    static bool
    init (image_type&, const value_type&, sqlite::statement_kind);

    static void
    init (value_type&, const image_type&, database*);

    static bool
    get_null (const image_type&);

    static void
    set_null (image_type&, sqlite::statement_kind);
  };

  // signal_time
  //
  template <>
  struct class_traits< ::pio::signal_time >
  {
    static const class_kind kind = class_composite;
  };

  template <>
  class access::composite_value_traits< ::pio::signal_time >
  {
    public:
    typedef ::pio::signal_time value_type;

    struct image_type
    {
      // start
      //
      double start_value;
      bool start_null;

      // end
      //
      double end_value;
      bool end_null;

      // timing
      //
      long long timing_value;
      bool timing_null;

      // phasing
      //
      long long phasing_value;
      bool phasing_null;
    };

    static bool
    grow (image_type&, bool*);

    static void
    bind (sqlite::bind*, image_type&, sqlite::statement_kind);

    static bool
    init (image_type&, const value_type&, sqlite::statement_kind);

    static void
    init (value_type&, const image_type&, database*);

    static bool
    get_null (const image_type&);

    static void
    set_null (image_type&, sqlite::statement_kind);
  };

  // phase_movement
  //
  template <>
  struct class_traits< ::pio::phase_movement >
  {
    static const class_kind kind = class_composite;
  };

  template <>
  class access::composite_value_traits< ::pio::phase_movement >
  {
    public:
    typedef ::pio::phase_movement value_type;

    struct image_type
    {
      // movement
      //
      details::buffer movement_value;
      std::size_t movement_size;
      bool movement_null;

      // link
      //
      long long link_value;
      bool link_null;

      // dir
      //
      long long dir_value;
      bool dir_null;

      // to_link
      //
      long long to_link_value;
      bool to_link_null;

      // protect
      //
      details::buffer protect_value;
      std::size_t protect_size;
      bool protect_null;
    };

    static bool
    grow (image_type&, bool*);

    static void
    bind (sqlite::bind*, image_type&, sqlite::statement_kind);

    static bool
    init (image_type&, const value_type&, sqlite::statement_kind);

    static void
    init (value_type&, const image_type&, database*);

    static bool
    get_null (const image_type&);

    static void
    set_null (image_type&, sqlite::statement_kind);
  };

  // Node
  //
  template <>
  struct class_traits< ::pio::Node >
  {
    static const class_kind kind = class_object;
  };

  template <typename A>
  struct query_columns< ::pio::Node, A >
  {
    // node
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    node_type_;

    static const node_type_ node;

    // x
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    x_type_;

    static const x_type_ x;

    // y
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    y_type_;

    static const y_type_ y;

    // z
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    z_type_;

    static const z_type_ z;

    // subarea
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    subarea_type_;

    static const subarea_type_ subarea;

    // part
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    part_type_;

    static const part_type_ part;
  };

  template <typename A>
  const typename query_columns< ::pio::Node, A >::node_type_
  query_columns< ::pio::Node, A >::
  node (A::table_name, "\"node\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Node, A >::x_type_
  query_columns< ::pio::Node, A >::
  x (A::table_name, "\"x\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Node, A >::y_type_
  query_columns< ::pio::Node, A >::
  y (A::table_name, "\"y\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Node, A >::z_type_
  query_columns< ::pio::Node, A >::
  z (A::table_name, "\"z\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Node, A >::subarea_type_
  query_columns< ::pio::Node, A >::
  subarea (A::table_name, "\"subarea\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Node, A >::part_type_
  query_columns< ::pio::Node, A >::
  part (A::table_name, "\"part\"", 0);

  template <typename A>
  struct pointer_query_columns< ::pio::Node, A >:
    query_columns< ::pio::Node, A >
  {
  };

  template <>
  class access::object_traits< ::pio::Node >
  {
    public:
    typedef ::pio::Node object_type;
    typedef ::std::tr1::shared_ptr< ::pio::Node > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef int id_type;
    static const bool auto_id = false;

    struct id_image_type
    {
      long long id_value;
      bool id_null;

      std::size_t version;
    };

    static const bool abstract = false;

    struct image_type
    {
      // node
      //
      long long node_value;
      bool node_null;

      // x
      //
      double x_value;
      bool x_null;

      // y
      //
      double y_value;
      bool y_null;

      // z
      //
      double z_value;
      bool z_null;

      // subarea
      //
      long long subarea_value;
      bool subarea_null;

      // part
      //
      long long part_value;
      bool part_null;

      std::size_t version;
    };

    static id_type
    id (const object_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&, bool*);

    static void
    bind (sqlite::bind*,
          image_type&,
          sqlite::statement_kind);

    static void
    bind (sqlite::bind*, id_image_type&);

    static bool
    init (image_type&, const object_type&, sqlite::statement_kind);

    static void
    init (object_type&, const image_type&, database*);

    static void
    init (id_image_type&, const id_type&);

    typedef
    odb::pointer_cache_traits<pointer_type>
    pointer_cache_traits;
    typedef
    odb::reference_cache_traits<object_type>
    reference_cache_traits;

    typedef sqlite::object_statements<object_type> statements_type;

    typedef sqlite::query query_base_type;

    struct container_statement_cache_type;

    static const std::size_t column_count = 6UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);

    static void
    persist (database&, const object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static bool
    create_schema (database&, unsigned short pass, bool drop);

    public:
    static bool
    find_ (statements_type&, const id_type*);

    static void
    load_ (statements_type&, object_type&);
  };

  // Zone
  //
  template <>
  struct class_traits< ::pio::Zone >
  {
    static const class_kind kind = class_object;
  };

  template <typename A>
  struct query_columns< ::pio::Zone, A >
  {
    // zone
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    zone_type_;

    static const zone_type_ zone;

    // x
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    x_type_;

    static const x_type_ x;

    // y
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    y_type_;

    static const y_type_ y;

    // z
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    z_type_;

    static const z_type_ z;

    // area
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    area_type_;

    static const area_type_ area;

    // min_x
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    min_x_type_;

    static const min_x_type_ min_x;

    // min_y
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    min_y_type_;

    static const min_y_type_ min_y;

    // max_x
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    max_x_type_;

    static const max_x_type_ max_x;

    // max_y
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    max_y_type_;

    static const max_y_type_ max_y;
  };

  template <typename A>
  const typename query_columns< ::pio::Zone, A >::zone_type_
  query_columns< ::pio::Zone, A >::
  zone (A::table_name, "\"zone\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Zone, A >::x_type_
  query_columns< ::pio::Zone, A >::
  x (A::table_name, "\"x\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Zone, A >::y_type_
  query_columns< ::pio::Zone, A >::
  y (A::table_name, "\"y\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Zone, A >::z_type_
  query_columns< ::pio::Zone, A >::
  z (A::table_name, "\"z\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Zone, A >::area_type_
  query_columns< ::pio::Zone, A >::
  area (A::table_name, "\"area\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Zone, A >::min_x_type_
  query_columns< ::pio::Zone, A >::
  min_x (A::table_name, "\"min_x\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Zone, A >::min_y_type_
  query_columns< ::pio::Zone, A >::
  min_y (A::table_name, "\"min_y\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Zone, A >::max_x_type_
  query_columns< ::pio::Zone, A >::
  max_x (A::table_name, "\"max_x\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Zone, A >::max_y_type_
  query_columns< ::pio::Zone, A >::
  max_y (A::table_name, "\"max_y\"", 0);

  template <typename A>
  struct pointer_query_columns< ::pio::Zone, A >:
    query_columns< ::pio::Zone, A >
  {
  };

  template <>
  class access::object_traits< ::pio::Zone >
  {
    public:
    typedef ::pio::Zone object_type;
    typedef ::std::tr1::shared_ptr< ::pio::Zone > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef int id_type;
    static const bool auto_id = false;

    struct id_image_type
    {
      long long id_value;
      bool id_null;

      std::size_t version;
    };

    static const bool abstract = false;

    struct image_type
    {
      // zone
      //
      long long zone_value;
      bool zone_null;

      // x
      //
      double x_value;
      bool x_null;

      // y
      //
      double y_value;
      bool y_null;

      // z
      //
      double z_value;
      bool z_null;

      // area
      //
      long long area_value;
      bool area_null;

      // min_x
      //
      double min_x_value;
      bool min_x_null;

      // min_y
      //
      double min_y_value;
      bool min_y_null;

      // max_x
      //
      double max_x_value;
      bool max_x_null;

      // max_y
      //
      double max_y_value;
      bool max_y_null;

      std::size_t version;
    };

    static id_type
    id (const object_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&, bool*);

    static void
    bind (sqlite::bind*,
          image_type&,
          sqlite::statement_kind);

    static void
    bind (sqlite::bind*, id_image_type&);

    static bool
    init (image_type&, const object_type&, sqlite::statement_kind);

    static void
    init (object_type&, const image_type&, database*);

    static void
    init (id_image_type&, const id_type&);

    typedef
    odb::pointer_cache_traits<pointer_type>
    pointer_cache_traits;
    typedef
    odb::reference_cache_traits<object_type>
    reference_cache_traits;

    typedef sqlite::object_statements<object_type> statements_type;

    typedef sqlite::query query_base_type;

    struct container_statement_cache_type;

    static const std::size_t column_count = 9UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);

    static void
    persist (database&, const object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static bool
    create_schema (database&, unsigned short pass, bool drop);

    public:
    static bool
    find_ (statements_type&, const id_type*);

    static void
    load_ (statements_type&, object_type&);
  };

  // Shape
  //
  template <>
  struct class_traits< ::pio::Shape >
  {
    static const class_kind kind = class_object;
  };

  template <typename A>
  struct pointer_query_columns< ::pio::Shape, A >
  {
    // auto_id
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        long unsigned int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    auto_id_type_;

    static const auto_id_type_ auto_id;

    // link
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    link_type_;

    static const link_type_ link;

    // points
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    points_type_;

    static const points_type_ points;
  };

  template <typename A>
  const typename pointer_query_columns< ::pio::Shape, A >::auto_id_type_
  pointer_query_columns< ::pio::Shape, A >::
  auto_id (A::table_name, "\"auto_id\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Shape, A >::link_type_
  pointer_query_columns< ::pio::Shape, A >::
  link (A::table_name, "\"link\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Shape, A >::points_type_
  pointer_query_columns< ::pio::Shape, A >::
  points (A::table_name, "\"points\"", 0);

  template <>
  class access::object_traits< ::pio::Shape >
  {
    public:
    typedef ::pio::Shape object_type;
    typedef ::std::tr1::shared_ptr< ::pio::Shape > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef long unsigned int id_type;
    static const bool auto_id = true;

    struct id_image_type
    {
      long long id_value;
      bool id_null;

      std::size_t version;
    };

    static const bool abstract = false;

    struct image_type
    {
      // auto_id
      //
      long long auto_id_value;
      bool auto_id_null;

      // link
      //
      long long link_value;
      bool link_null;

      // points
      //
      long long points_value;
      bool points_null;

      std::size_t version;
    };

    // nested_records
    //
    struct nested_records_traits
    {
      static const std::size_t id_column_count = 1UL;
      static const std::size_t cond_column_count = 1UL;
      static const std::size_t data_column_count = 5UL;

      static const char insert_one_statement[];
      static const char select_all_statement[];
      static const char delete_all_statement[];

      typedef ::std::vector< ::pio::shape_geometry > container_type;
      typedef
      odb::access::container_traits<container_type>
      container_traits_type;
      typedef container_traits_type::index_type index_type;
      typedef container_traits_type::value_type value_type;

      typedef ordered_functions<index_type, value_type> functions_type;
      typedef sqlite::container_statements< nested_records_traits > statements_type;

      struct cond_image_type
      {
        // index
        //
        long long index_value;
        bool index_null;

        std::size_t version;
      };

      struct data_image_type
      {
        // index
        //
        long long index_value;
        bool index_null;

        // value
        //
        composite_value_traits< value_type >::image_type value_value;

        std::size_t version;
      };

      static void
      bind (sqlite::bind*,
            const sqlite::bind* id,
            std::size_t id_size,
            cond_image_type&);

      static void
      bind (sqlite::bind*,
            const sqlite::bind* id,
            std::size_t id_size,
            data_image_type&);

      static void
      grow (data_image_type&, bool*);

      static void
      init (data_image_type&, index_type, const value_type&);

      static void
      init (index_type&, value_type&, const data_image_type&, database*);

      static void
      insert_one (index_type, const value_type&, void*);

      static bool
      load_all (index_type&, value_type&, void*);

      static void
      delete_all (void*);

      static void
      persist (const container_type&,
               const sqlite::binding& id,
               statements_type&);

      static void
      load (container_type&,
            const sqlite::binding& id,
            statements_type&);

      static void
      update (const container_type&,
              const sqlite::binding& id,
              statements_type&);

      static void
      erase (const sqlite::binding& id, statements_type&);
    };

    static id_type
    id (const object_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&, bool*);

    static void
    bind (sqlite::bind*,
          image_type&,
          sqlite::statement_kind);

    static void
    bind (sqlite::bind*, id_image_type&);

    static bool
    init (image_type&, const object_type&, sqlite::statement_kind);

    static void
    init (object_type&, const image_type&, database*);

    static void
    init (id_image_type&, const id_type&);

    typedef
    odb::pointer_cache_traits<pointer_type>
    pointer_cache_traits;
    typedef
    odb::reference_cache_traits<object_type>
    reference_cache_traits;

    typedef sqlite::object_statements<object_type> statements_type;

    typedef sqlite::query query_base_type;

    struct container_statement_cache_type;

    static const std::size_t column_count = 3UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static bool
    create_schema (database&, unsigned short pass, bool drop);

    public:
    static bool
    find_ (statements_type&, const id_type*);

    static void
    load_ (statements_type&, object_type&);
  };

  // Link
  //
  template <>
  struct class_traits< ::pio::Link >
  {
    static const class_kind kind = class_object;
  };

  template <typename A>
  struct pointer_query_columns< ::pio::Link, A >
  {
    // link
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    link_type_;

    static const link_type_ link;

    // name
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        ::std::string,
        sqlite::id_text >::query_type,
      sqlite::id_text >
    name_type_;

    static const name_type_ name;

    // node_a
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    node_a_type_;

    static const node_a_type_ node_a;

    // node_b
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    node_b_type_;

    static const node_b_type_ node_b;

    // length
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    length_type_;

    static const length_type_ length;

    // setback_a
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    setback_a_type_;

    static const setback_a_type_ setback_a;

    // setback_b
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    setback_b_type_;

    static const setback_b_type_ setback_b;

    // bearing_a
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    bearing_a_type_;

    static const bearing_a_type_ bearing_a;

    // bearing_b
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    bearing_b_type_;

    static const bearing_b_type_ bearing_b;

    // type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        ::std::string,
        sqlite::id_text >::query_type,
      sqlite::id_text >
    type_type_;

    static const type_type_ type;

    // divided
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    divided_type_;

    static const divided_type_ divided;

    // area_type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    area_type_type_;

    static const area_type_type_ area_type;

    // use
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    use_type_;

    static const use_type_ use;

    // grade
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    grade_type_;

    static const grade_type_ grade;

    // lanes_ab
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    lanes_ab_type_;

    static const lanes_ab_type_ lanes_ab;

    // speed_ab
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    speed_ab_type_;

    static const speed_ab_type_ speed_ab;

    // fspd_ab
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    fspd_ab_type_;

    static const fspd_ab_type_ fspd_ab;

    // cap_ab
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    cap_ab_type_;

    static const cap_ab_type_ cap_ab;

    // lanes_ba
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    lanes_ba_type_;

    static const lanes_ba_type_ lanes_ba;

    // speed_ba
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    speed_ba_type_;

    static const speed_ba_type_ speed_ba;

    // fspd_ba
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    fspd_ba_type_;

    static const fspd_ba_type_ fspd_ba;

    // cap_ba
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    cap_ba_type_;

    static const cap_ba_type_ cap_ba;

    // left_ab
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    left_ab_type_;

    static const left_ab_type_ left_ab;

    // right_ab
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    right_ab_type_;

    static const right_ab_type_ right_ab;

    // left_ba
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    left_ba_type_;

    static const left_ba_type_ left_ba;

    // right_ba
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    right_ba_type_;

    static const right_ba_type_ right_ba;
  };

  template <typename A>
  const typename pointer_query_columns< ::pio::Link, A >::link_type_
  pointer_query_columns< ::pio::Link, A >::
  link (A::table_name, "\"link\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Link, A >::name_type_
  pointer_query_columns< ::pio::Link, A >::
  name (A::table_name, "\"name\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Link, A >::node_a_type_
  pointer_query_columns< ::pio::Link, A >::
  node_a (A::table_name, "\"node_a\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Link, A >::node_b_type_
  pointer_query_columns< ::pio::Link, A >::
  node_b (A::table_name, "\"node_b\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Link, A >::length_type_
  pointer_query_columns< ::pio::Link, A >::
  length (A::table_name, "\"length\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Link, A >::setback_a_type_
  pointer_query_columns< ::pio::Link, A >::
  setback_a (A::table_name, "\"setback_a\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Link, A >::setback_b_type_
  pointer_query_columns< ::pio::Link, A >::
  setback_b (A::table_name, "\"setback_b\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Link, A >::bearing_a_type_
  pointer_query_columns< ::pio::Link, A >::
  bearing_a (A::table_name, "\"bearing_a\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Link, A >::bearing_b_type_
  pointer_query_columns< ::pio::Link, A >::
  bearing_b (A::table_name, "\"bearing_b\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Link, A >::type_type_
  pointer_query_columns< ::pio::Link, A >::
  type (A::table_name, "\"type\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Link, A >::divided_type_
  pointer_query_columns< ::pio::Link, A >::
  divided (A::table_name, "\"divided\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Link, A >::area_type_type_
  pointer_query_columns< ::pio::Link, A >::
  area_type (A::table_name, "\"area_type\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Link, A >::use_type_
  pointer_query_columns< ::pio::Link, A >::
  use (A::table_name, "\"use\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Link, A >::grade_type_
  pointer_query_columns< ::pio::Link, A >::
  grade (A::table_name, "\"grade\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Link, A >::lanes_ab_type_
  pointer_query_columns< ::pio::Link, A >::
  lanes_ab (A::table_name, "\"lanes_ab\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Link, A >::speed_ab_type_
  pointer_query_columns< ::pio::Link, A >::
  speed_ab (A::table_name, "\"speed_ab\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Link, A >::fspd_ab_type_
  pointer_query_columns< ::pio::Link, A >::
  fspd_ab (A::table_name, "\"fspd_ab\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Link, A >::cap_ab_type_
  pointer_query_columns< ::pio::Link, A >::
  cap_ab (A::table_name, "\"cap_ab\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Link, A >::lanes_ba_type_
  pointer_query_columns< ::pio::Link, A >::
  lanes_ba (A::table_name, "\"lanes_ba\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Link, A >::speed_ba_type_
  pointer_query_columns< ::pio::Link, A >::
  speed_ba (A::table_name, "\"speed_ba\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Link, A >::fspd_ba_type_
  pointer_query_columns< ::pio::Link, A >::
  fspd_ba (A::table_name, "\"fspd_ba\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Link, A >::cap_ba_type_
  pointer_query_columns< ::pio::Link, A >::
  cap_ba (A::table_name, "\"cap_ba\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Link, A >::left_ab_type_
  pointer_query_columns< ::pio::Link, A >::
  left_ab (A::table_name, "\"left_ab\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Link, A >::right_ab_type_
  pointer_query_columns< ::pio::Link, A >::
  right_ab (A::table_name, "\"right_ab\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Link, A >::left_ba_type_
  pointer_query_columns< ::pio::Link, A >::
  left_ba (A::table_name, "\"left_ba\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Link, A >::right_ba_type_
  pointer_query_columns< ::pio::Link, A >::
  right_ba (A::table_name, "\"right_ba\"", 0);

  template <>
  class access::object_traits< ::pio::Link >
  {
    public:
    typedef ::pio::Link object_type;
    typedef ::std::tr1::shared_ptr< ::pio::Link > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef int id_type;
    static const bool auto_id = false;

    struct id_image_type
    {
      long long id_value;
      bool id_null;

      std::size_t version;
    };

    static const bool abstract = false;

    struct image_type
    {
      // link
      //
      long long link_value;
      bool link_null;

      // name
      //
      details::buffer name_value;
      std::size_t name_size;
      bool name_null;

      // node_a
      //
      long long node_a_value;
      bool node_a_null;

      // node_b
      //
      long long node_b_value;
      bool node_b_null;

      // length
      //
      double length_value;
      bool length_null;

      // setback_a
      //
      double setback_a_value;
      bool setback_a_null;

      // setback_b
      //
      double setback_b_value;
      bool setback_b_null;

      // bearing_a
      //
      long long bearing_a_value;
      bool bearing_a_null;

      // bearing_b
      //
      long long bearing_b_value;
      bool bearing_b_null;

      // type
      //
      details::buffer type_value;
      std::size_t type_size;
      bool type_null;

      // divided
      //
      long long divided_value;
      bool divided_null;

      // area_type
      //
      long long area_type_value;
      bool area_type_null;

      // use
      //
      long long use_value;
      bool use_null;

      // grade
      //
      double grade_value;
      bool grade_null;

      // lanes_ab
      //
      long long lanes_ab_value;
      bool lanes_ab_null;

      // speed_ab
      //
      double speed_ab_value;
      bool speed_ab_null;

      // fspd_ab
      //
      double fspd_ab_value;
      bool fspd_ab_null;

      // cap_ab
      //
      long long cap_ab_value;
      bool cap_ab_null;

      // lanes_ba
      //
      long long lanes_ba_value;
      bool lanes_ba_null;

      // speed_ba
      //
      double speed_ba_value;
      bool speed_ba_null;

      // fspd_ba
      //
      double fspd_ba_value;
      bool fspd_ba_null;

      // cap_ba
      //
      long long cap_ba_value;
      bool cap_ba_null;

      // left_ab
      //
      long long left_ab_value;
      bool left_ab_null;

      // right_ab
      //
      long long right_ab_value;
      bool right_ab_null;

      // left_ba
      //
      long long left_ba_value;
      bool left_ba_null;

      // right_ba
      //
      long long right_ba_value;
      bool right_ba_null;

      std::size_t version;
    };

    static id_type
    id (const object_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&, bool*);

    static void
    bind (sqlite::bind*,
          image_type&,
          sqlite::statement_kind);

    static void
    bind (sqlite::bind*, id_image_type&);

    static bool
    init (image_type&, const object_type&, sqlite::statement_kind);

    static void
    init (object_type&, const image_type&, database*);

    static void
    init (id_image_type&, const id_type&);

    typedef
    odb::pointer_cache_traits<pointer_type>
    pointer_cache_traits;
    typedef
    odb::reference_cache_traits<object_type>
    reference_cache_traits;

    typedef sqlite::object_statements<object_type> statements_type;

    typedef sqlite::query query_base_type;

    struct container_statement_cache_type;

    static const std::size_t column_count = 26UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);

    static void
    persist (database&, const object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static bool
    create_schema (database&, unsigned short pass, bool drop);

    public:
    static bool
    find_ (statements_type&, const id_type*);

    static void
    load_ (statements_type&, object_type&);
  };

  // Pocket
  //
  template <>
  struct class_traits< ::pio::Pocket >
  {
    static const class_kind kind = class_object;
  };

  template <typename A>
  struct pointer_query_columns< ::pio::Pocket, A >
  {
    // auto_id
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        long unsigned int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    auto_id_type_;

    static const auto_id_type_ auto_id;

    // link
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    link_type_;

    static const link_type_ link;

    // dir
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    dir_type_;

    static const dir_type_ dir;

    // type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        ::std::string,
        sqlite::id_text >::query_type,
      sqlite::id_text >
    type_type_;

    static const type_type_ type;

    // lanes
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    lanes_type_;

    static const lanes_type_ lanes;

    // length
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    length_type_;

    static const length_type_ length;

    // offset
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    offset_type_;

    static const offset_type_ offset;
  };

  template <typename A>
  const typename pointer_query_columns< ::pio::Pocket, A >::auto_id_type_
  pointer_query_columns< ::pio::Pocket, A >::
  auto_id (A::table_name, "\"auto_id\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Pocket, A >::link_type_
  pointer_query_columns< ::pio::Pocket, A >::
  link (A::table_name, "\"link\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Pocket, A >::dir_type_
  pointer_query_columns< ::pio::Pocket, A >::
  dir (A::table_name, "\"dir\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Pocket, A >::type_type_
  pointer_query_columns< ::pio::Pocket, A >::
  type (A::table_name, "\"type\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Pocket, A >::lanes_type_
  pointer_query_columns< ::pio::Pocket, A >::
  lanes (A::table_name, "\"lanes\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Pocket, A >::length_type_
  pointer_query_columns< ::pio::Pocket, A >::
  length (A::table_name, "\"length\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Pocket, A >::offset_type_
  pointer_query_columns< ::pio::Pocket, A >::
  offset (A::table_name, "\"offset\"", 0);

  template <>
  class access::object_traits< ::pio::Pocket >
  {
    public:
    typedef ::pio::Pocket object_type;
    typedef ::std::tr1::shared_ptr< ::pio::Pocket > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef long unsigned int id_type;
    static const bool auto_id = true;

    struct id_image_type
    {
      long long id_value;
      bool id_null;

      std::size_t version;
    };

    static const bool abstract = false;

    struct image_type
    {
      // auto_id
      //
      long long auto_id_value;
      bool auto_id_null;

      // link
      //
      long long link_value;
      bool link_null;

      // dir
      //
      long long dir_value;
      bool dir_null;

      // type
      //
      details::buffer type_value;
      std::size_t type_size;
      bool type_null;

      // lanes
      //
      long long lanes_value;
      bool lanes_null;

      // length
      //
      double length_value;
      bool length_null;

      // offset
      //
      double offset_value;
      bool offset_null;

      std::size_t version;
    };

    static id_type
    id (const object_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&, bool*);

    static void
    bind (sqlite::bind*,
          image_type&,
          sqlite::statement_kind);

    static void
    bind (sqlite::bind*, id_image_type&);

    static bool
    init (image_type&, const object_type&, sqlite::statement_kind);

    static void
    init (object_type&, const image_type&, database*);

    static void
    init (id_image_type&, const id_type&);

    typedef
    odb::pointer_cache_traits<pointer_type>
    pointer_cache_traits;
    typedef
    odb::reference_cache_traits<object_type>
    reference_cache_traits;

    typedef sqlite::object_statements<object_type> statements_type;

    typedef sqlite::query query_base_type;

    struct container_statement_cache_type;

    static const std::size_t column_count = 7UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static bool
    create_schema (database&, unsigned short pass, bool drop);

    public:
    static bool
    find_ (statements_type&, const id_type*);

    static void
    load_ (statements_type&, object_type&);
  };

  // Lane_Use
  //
  template <>
  struct class_traits< ::pio::Lane_Use >
  {
    static const class_kind kind = class_object;
  };

  template <typename A>
  struct pointer_query_columns< ::pio::Lane_Use, A >
  {
    // auto_id
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        long unsigned int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    auto_id_type_;

    static const auto_id_type_ auto_id;

    // link
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    link_type_;

    static const link_type_ link;

    // dir
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    dir_type_;

    static const dir_type_ dir;

    // lanes
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    lanes_type_;

    static const lanes_type_ lanes;

    // use
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    use_type_;

    static const use_type_ use;

    // type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    type_type_;

    static const type_type_ type;

    // min_type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    min_type_type_;

    static const min_type_type_ min_type;

    // max_type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    max_type_type_;

    static const max_type_type_ max_type;

    // min_trav
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    min_trav_type_;

    static const min_trav_type_ min_trav;

    // max_trav
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    max_trav_type_;

    static const max_trav_type_ max_trav;

    // start
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    start_type_;

    static const start_type_ start;

    // end
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    end_type_;

    static const end_type_ end;

    // offset
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    offset_type_;

    static const offset_type_ offset;

    // length
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    length_type_;

    static const length_type_ length;

    // toll
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    toll_type_;

    static const toll_type_ toll;

    // rate
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    rate_type_;

    static const rate_type_ rate;

    // min_delay
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    min_delay_type_;

    static const min_delay_type_ min_delay;

    // max_delay
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    max_delay_type_;

    static const max_delay_type_ max_delay;
  };

  template <typename A>
  const typename pointer_query_columns< ::pio::Lane_Use, A >::auto_id_type_
  pointer_query_columns< ::pio::Lane_Use, A >::
  auto_id (A::table_name, "\"auto_id\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Lane_Use, A >::link_type_
  pointer_query_columns< ::pio::Lane_Use, A >::
  link (A::table_name, "\"link\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Lane_Use, A >::dir_type_
  pointer_query_columns< ::pio::Lane_Use, A >::
  dir (A::table_name, "\"dir\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Lane_Use, A >::lanes_type_
  pointer_query_columns< ::pio::Lane_Use, A >::
  lanes (A::table_name, "\"lanes\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Lane_Use, A >::use_type_
  pointer_query_columns< ::pio::Lane_Use, A >::
  use (A::table_name, "\"use\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Lane_Use, A >::type_type_
  pointer_query_columns< ::pio::Lane_Use, A >::
  type (A::table_name, "\"type\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Lane_Use, A >::min_type_type_
  pointer_query_columns< ::pio::Lane_Use, A >::
  min_type (A::table_name, "\"min_type\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Lane_Use, A >::max_type_type_
  pointer_query_columns< ::pio::Lane_Use, A >::
  max_type (A::table_name, "\"max_type\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Lane_Use, A >::min_trav_type_
  pointer_query_columns< ::pio::Lane_Use, A >::
  min_trav (A::table_name, "\"min_trav\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Lane_Use, A >::max_trav_type_
  pointer_query_columns< ::pio::Lane_Use, A >::
  max_trav (A::table_name, "\"max_trav\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Lane_Use, A >::start_type_
  pointer_query_columns< ::pio::Lane_Use, A >::
  start (A::table_name, "\"start\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Lane_Use, A >::end_type_
  pointer_query_columns< ::pio::Lane_Use, A >::
  end (A::table_name, "\"end\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Lane_Use, A >::offset_type_
  pointer_query_columns< ::pio::Lane_Use, A >::
  offset (A::table_name, "\"offset\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Lane_Use, A >::length_type_
  pointer_query_columns< ::pio::Lane_Use, A >::
  length (A::table_name, "\"length\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Lane_Use, A >::toll_type_
  pointer_query_columns< ::pio::Lane_Use, A >::
  toll (A::table_name, "\"toll\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Lane_Use, A >::rate_type_
  pointer_query_columns< ::pio::Lane_Use, A >::
  rate (A::table_name, "\"rate\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Lane_Use, A >::min_delay_type_
  pointer_query_columns< ::pio::Lane_Use, A >::
  min_delay (A::table_name, "\"min_delay\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Lane_Use, A >::max_delay_type_
  pointer_query_columns< ::pio::Lane_Use, A >::
  max_delay (A::table_name, "\"max_delay\"", 0);

  template <>
  class access::object_traits< ::pio::Lane_Use >
  {
    public:
    typedef ::pio::Lane_Use object_type;
    typedef ::std::tr1::shared_ptr< ::pio::Lane_Use > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef long unsigned int id_type;
    static const bool auto_id = true;

    struct id_image_type
    {
      long long id_value;
      bool id_null;

      std::size_t version;
    };

    static const bool abstract = false;

    struct image_type
    {
      // auto_id
      //
      long long auto_id_value;
      bool auto_id_null;

      // link
      //
      long long link_value;
      bool link_null;

      // dir
      //
      long long dir_value;
      bool dir_null;

      // lanes
      //
      long long lanes_value;
      bool lanes_null;

      // use
      //
      long long use_value;
      bool use_null;

      // type
      //
      long long type_value;
      bool type_null;

      // min_type
      //
      long long min_type_value;
      bool min_type_null;

      // max_type
      //
      long long max_type_value;
      bool max_type_null;

      // min_trav
      //
      long long min_trav_value;
      bool min_trav_null;

      // max_trav
      //
      long long max_trav_value;
      bool max_trav_null;

      // start
      //
      double start_value;
      bool start_null;

      // end
      //
      double end_value;
      bool end_null;

      // offset
      //
      double offset_value;
      bool offset_null;

      // length
      //
      double length_value;
      bool length_null;

      // toll
      //
      long long toll_value;
      bool toll_null;

      // rate
      //
      double rate_value;
      bool rate_null;

      // min_delay
      //
      double min_delay_value;
      bool min_delay_null;

      // max_delay
      //
      double max_delay_value;
      bool max_delay_null;

      std::size_t version;
    };

    static id_type
    id (const object_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&, bool*);

    static void
    bind (sqlite::bind*,
          image_type&,
          sqlite::statement_kind);

    static void
    bind (sqlite::bind*, id_image_type&);

    static bool
    init (image_type&, const object_type&, sqlite::statement_kind);

    static void
    init (object_type&, const image_type&, database*);

    static void
    init (id_image_type&, const id_type&);

    typedef
    odb::pointer_cache_traits<pointer_type>
    pointer_cache_traits;
    typedef
    odb::reference_cache_traits<object_type>
    reference_cache_traits;

    typedef sqlite::object_statements<object_type> statements_type;

    typedef sqlite::query query_base_type;

    struct container_statement_cache_type;

    static const std::size_t column_count = 18UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static bool
    create_schema (database&, unsigned short pass, bool drop);

    public:
    static bool
    find_ (statements_type&, const id_type*);

    static void
    load_ (statements_type&, object_type&);
  };

  // Connect
  //
  template <>
  struct class_traits< ::pio::Connect >
  {
    static const class_kind kind = class_object;
  };

  template <typename A>
  struct pointer_query_columns< ::pio::Connect, A >
  {
    // auto_id
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        long unsigned int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    auto_id_type_;

    static const auto_id_type_ auto_id;

    // link
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    link_type_;

    static const link_type_ link;

    // dir
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    dir_type_;

    static const dir_type_ dir;

    // to_link
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    to_link_type_;

    static const to_link_type_ to_link;

    // lanes
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        ::std::string,
        sqlite::id_text >::query_type,
      sqlite::id_text >
    lanes_type_;

    static const lanes_type_ lanes;

    // to_lanes
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        ::std::string,
        sqlite::id_text >::query_type,
      sqlite::id_text >
    to_lanes_type_;

    static const to_lanes_type_ to_lanes;

    // type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        ::std::string,
        sqlite::id_text >::query_type,
      sqlite::id_text >
    type_type_;

    static const type_type_ type;

    // penalty
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    penalty_type_;

    static const penalty_type_ penalty;

    // speed
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    speed_type_;

    static const speed_type_ speed;

    // capacity
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    capacity_type_;

    static const capacity_type_ capacity;

    // in_high
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    in_high_type_;

    static const in_high_type_ in_high;

    // out_high
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    out_high_type_;

    static const out_high_type_ out_high;
  };

  template <typename A>
  const typename pointer_query_columns< ::pio::Connect, A >::auto_id_type_
  pointer_query_columns< ::pio::Connect, A >::
  auto_id (A::table_name, "\"auto_id\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Connect, A >::link_type_
  pointer_query_columns< ::pio::Connect, A >::
  link (A::table_name, "\"link\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Connect, A >::dir_type_
  pointer_query_columns< ::pio::Connect, A >::
  dir (A::table_name, "\"dir\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Connect, A >::to_link_type_
  pointer_query_columns< ::pio::Connect, A >::
  to_link (A::table_name, "\"to_link\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Connect, A >::lanes_type_
  pointer_query_columns< ::pio::Connect, A >::
  lanes (A::table_name, "\"lanes\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Connect, A >::to_lanes_type_
  pointer_query_columns< ::pio::Connect, A >::
  to_lanes (A::table_name, "\"to_lanes\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Connect, A >::type_type_
  pointer_query_columns< ::pio::Connect, A >::
  type (A::table_name, "\"type\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Connect, A >::penalty_type_
  pointer_query_columns< ::pio::Connect, A >::
  penalty (A::table_name, "\"penalty\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Connect, A >::speed_type_
  pointer_query_columns< ::pio::Connect, A >::
  speed (A::table_name, "\"speed\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Connect, A >::capacity_type_
  pointer_query_columns< ::pio::Connect, A >::
  capacity (A::table_name, "\"capacity\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Connect, A >::in_high_type_
  pointer_query_columns< ::pio::Connect, A >::
  in_high (A::table_name, "\"in_high\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Connect, A >::out_high_type_
  pointer_query_columns< ::pio::Connect, A >::
  out_high (A::table_name, "\"out_high\"", 0);

  template <>
  class access::object_traits< ::pio::Connect >
  {
    public:
    typedef ::pio::Connect object_type;
    typedef ::std::tr1::shared_ptr< ::pio::Connect > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef long unsigned int id_type;
    static const bool auto_id = true;

    struct id_image_type
    {
      long long id_value;
      bool id_null;

      std::size_t version;
    };

    static const bool abstract = false;

    struct image_type
    {
      // auto_id
      //
      long long auto_id_value;
      bool auto_id_null;

      // link
      //
      long long link_value;
      bool link_null;

      // dir
      //
      long long dir_value;
      bool dir_null;

      // to_link
      //
      long long to_link_value;
      bool to_link_null;

      // lanes
      //
      details::buffer lanes_value;
      std::size_t lanes_size;
      bool lanes_null;

      // to_lanes
      //
      details::buffer to_lanes_value;
      std::size_t to_lanes_size;
      bool to_lanes_null;

      // type
      //
      details::buffer type_value;
      std::size_t type_size;
      bool type_null;

      // penalty
      //
      long long penalty_value;
      bool penalty_null;

      // speed
      //
      double speed_value;
      bool speed_null;

      // capacity
      //
      long long capacity_value;
      bool capacity_null;

      // in_high
      //
      long long in_high_value;
      bool in_high_null;

      // out_high
      //
      long long out_high_value;
      bool out_high_null;

      std::size_t version;
    };

    static id_type
    id (const object_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&, bool*);

    static void
    bind (sqlite::bind*,
          image_type&,
          sqlite::statement_kind);

    static void
    bind (sqlite::bind*, id_image_type&);

    static bool
    init (image_type&, const object_type&, sqlite::statement_kind);

    static void
    init (object_type&, const image_type&, database*);

    static void
    init (id_image_type&, const id_type&);

    typedef
    odb::pointer_cache_traits<pointer_type>
    pointer_cache_traits;
    typedef
    odb::reference_cache_traits<object_type>
    reference_cache_traits;

    typedef sqlite::object_statements<object_type> statements_type;

    typedef sqlite::query query_base_type;

    struct container_statement_cache_type;

    static const std::size_t column_count = 12UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static bool
    create_schema (database&, unsigned short pass, bool drop);

    public:
    static bool
    find_ (statements_type&, const id_type*);

    static void
    load_ (statements_type&, object_type&);
  };

  // Turn_Pen
  //
  template <>
  struct class_traits< ::pio::Turn_Pen >
  {
    static const class_kind kind = class_object;
  };

  template <typename A>
  struct pointer_query_columns< ::pio::Turn_Pen, A >
  {
    // auto_id
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        long unsigned int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    auto_id_type_;

    static const auto_id_type_ auto_id;

    // link
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    link_type_;

    static const link_type_ link;

    // dir
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    dir_type_;

    static const dir_type_ dir;

    // to_link
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    to_link_type_;

    static const to_link_type_ to_link;

    // start
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    start_type_;

    static const start_type_ start;

    // end
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    end_type_;

    static const end_type_ end;

    // use
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    use_type_;

    static const use_type_ use;

    // min_type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    min_type_type_;

    static const min_type_type_ min_type;

    // max_type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    max_type_type_;

    static const max_type_type_ max_type;

    // penalty
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    penalty_type_;

    static const penalty_type_ penalty;

    // in_node
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    in_node_type_;

    static const in_node_type_ in_node;

    // out_node
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    out_node_type_;

    static const out_node_type_ out_node;
  };

  template <typename A>
  const typename pointer_query_columns< ::pio::Turn_Pen, A >::auto_id_type_
  pointer_query_columns< ::pio::Turn_Pen, A >::
  auto_id (A::table_name, "\"auto_id\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Turn_Pen, A >::link_type_
  pointer_query_columns< ::pio::Turn_Pen, A >::
  link (A::table_name, "\"link\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Turn_Pen, A >::dir_type_
  pointer_query_columns< ::pio::Turn_Pen, A >::
  dir (A::table_name, "\"dir\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Turn_Pen, A >::to_link_type_
  pointer_query_columns< ::pio::Turn_Pen, A >::
  to_link (A::table_name, "\"to_link\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Turn_Pen, A >::start_type_
  pointer_query_columns< ::pio::Turn_Pen, A >::
  start (A::table_name, "\"start\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Turn_Pen, A >::end_type_
  pointer_query_columns< ::pio::Turn_Pen, A >::
  end (A::table_name, "\"end\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Turn_Pen, A >::use_type_
  pointer_query_columns< ::pio::Turn_Pen, A >::
  use (A::table_name, "\"use\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Turn_Pen, A >::min_type_type_
  pointer_query_columns< ::pio::Turn_Pen, A >::
  min_type (A::table_name, "\"min_type\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Turn_Pen, A >::max_type_type_
  pointer_query_columns< ::pio::Turn_Pen, A >::
  max_type (A::table_name, "\"max_type\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Turn_Pen, A >::penalty_type_
  pointer_query_columns< ::pio::Turn_Pen, A >::
  penalty (A::table_name, "\"penalty\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Turn_Pen, A >::in_node_type_
  pointer_query_columns< ::pio::Turn_Pen, A >::
  in_node (A::table_name, "\"in_node\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Turn_Pen, A >::out_node_type_
  pointer_query_columns< ::pio::Turn_Pen, A >::
  out_node (A::table_name, "\"out_node\"", 0);

  template <>
  class access::object_traits< ::pio::Turn_Pen >
  {
    public:
    typedef ::pio::Turn_Pen object_type;
    typedef ::std::tr1::shared_ptr< ::pio::Turn_Pen > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef long unsigned int id_type;
    static const bool auto_id = true;

    struct id_image_type
    {
      long long id_value;
      bool id_null;

      std::size_t version;
    };

    static const bool abstract = false;

    struct image_type
    {
      // auto_id
      //
      long long auto_id_value;
      bool auto_id_null;

      // link
      //
      long long link_value;
      bool link_null;

      // dir
      //
      long long dir_value;
      bool dir_null;

      // to_link
      //
      long long to_link_value;
      bool to_link_null;

      // start
      //
      double start_value;
      bool start_null;

      // end
      //
      double end_value;
      bool end_null;

      // use
      //
      long long use_value;
      bool use_null;

      // min_type
      //
      long long min_type_value;
      bool min_type_null;

      // max_type
      //
      long long max_type_value;
      bool max_type_null;

      // penalty
      //
      long long penalty_value;
      bool penalty_null;

      // in_node
      //
      long long in_node_value;
      bool in_node_null;

      // out_node
      //
      long long out_node_value;
      bool out_node_null;

      std::size_t version;
    };

    static id_type
    id (const object_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&, bool*);

    static void
    bind (sqlite::bind*,
          image_type&,
          sqlite::statement_kind);

    static void
    bind (sqlite::bind*, id_image_type&);

    static bool
    init (image_type&, const object_type&, sqlite::statement_kind);

    static void
    init (object_type&, const image_type&, database*);

    static void
    init (id_image_type&, const id_type&);

    typedef
    odb::pointer_cache_traits<pointer_type>
    pointer_cache_traits;
    typedef
    odb::reference_cache_traits<object_type>
    reference_cache_traits;

    typedef sqlite::object_statements<object_type> statements_type;

    typedef sqlite::query query_base_type;

    struct container_statement_cache_type;

    static const std::size_t column_count = 12UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static bool
    create_schema (database&, unsigned short pass, bool drop);

    public:
    static bool
    find_ (statements_type&, const id_type*);

    static void
    load_ (statements_type&, object_type&);
  };

  // Parking
  //
  template <>
  struct class_traits< ::pio::Parking >
  {
    static const class_kind kind = class_object;
  };

  template <typename A>
  struct pointer_query_columns< ::pio::Parking, A >
  {
    // parking
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    parking_type_;

    static const parking_type_ parking;

    // link
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    link_type_;

    static const link_type_ link;

    // dir
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    dir_type_;

    static const dir_type_ dir;

    // offset
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    offset_type_;

    static const offset_type_ offset;

    // type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    type_type_;

    static const type_type_ type;

    // use
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    use_type_;

    static const use_type_ use;

    // start
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    start_type_;

    static const start_type_ start;

    // end
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    end_type_;

    static const end_type_ end;

    // space
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    space_type_;

    static const space_type_ space;

    // time_in
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    time_in_type_;

    static const time_in_type_ time_in;

    // time_out
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    time_out_type_;

    static const time_out_type_ time_out;

    // hourly
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    hourly_type_;

    static const hourly_type_ hourly;

    // daily
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    daily_type_;

    static const daily_type_ daily;
  };

  template <typename A>
  const typename pointer_query_columns< ::pio::Parking, A >::parking_type_
  pointer_query_columns< ::pio::Parking, A >::
  parking (A::table_name, "\"parking\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Parking, A >::link_type_
  pointer_query_columns< ::pio::Parking, A >::
  link (A::table_name, "\"link\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Parking, A >::dir_type_
  pointer_query_columns< ::pio::Parking, A >::
  dir (A::table_name, "\"dir\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Parking, A >::offset_type_
  pointer_query_columns< ::pio::Parking, A >::
  offset (A::table_name, "\"offset\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Parking, A >::type_type_
  pointer_query_columns< ::pio::Parking, A >::
  type (A::table_name, "\"type\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Parking, A >::use_type_
  pointer_query_columns< ::pio::Parking, A >::
  use (A::table_name, "\"use\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Parking, A >::start_type_
  pointer_query_columns< ::pio::Parking, A >::
  start (A::table_name, "\"start\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Parking, A >::end_type_
  pointer_query_columns< ::pio::Parking, A >::
  end (A::table_name, "\"end\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Parking, A >::space_type_
  pointer_query_columns< ::pio::Parking, A >::
  space (A::table_name, "\"space\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Parking, A >::time_in_type_
  pointer_query_columns< ::pio::Parking, A >::
  time_in (A::table_name, "\"time_in\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Parking, A >::time_out_type_
  pointer_query_columns< ::pio::Parking, A >::
  time_out (A::table_name, "\"time_out\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Parking, A >::hourly_type_
  pointer_query_columns< ::pio::Parking, A >::
  hourly (A::table_name, "\"hourly\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Parking, A >::daily_type_
  pointer_query_columns< ::pio::Parking, A >::
  daily (A::table_name, "\"daily\"", 0);

  template <>
  class access::object_traits< ::pio::Parking >
  {
    public:
    typedef ::pio::Parking object_type;
    typedef ::std::tr1::shared_ptr< ::pio::Parking > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef int id_type;
    static const bool auto_id = false;

    struct id_image_type
    {
      long long id_value;
      bool id_null;

      std::size_t version;
    };

    static const bool abstract = false;

    struct image_type
    {
      // parking
      //
      long long parking_value;
      bool parking_null;

      // link
      //
      long long link_value;
      bool link_null;

      // dir
      //
      long long dir_value;
      bool dir_null;

      // offset
      //
      double offset_value;
      bool offset_null;

      // type
      //
      long long type_value;
      bool type_null;

      // use
      //
      long long use_value;
      bool use_null;

      // start
      //
      double start_value;
      bool start_null;

      // end
      //
      double end_value;
      bool end_null;

      // space
      //
      long long space_value;
      bool space_null;

      // time_in
      //
      double time_in_value;
      bool time_in_null;

      // time_out
      //
      double time_out_value;
      bool time_out_null;

      // hourly
      //
      long long hourly_value;
      bool hourly_null;

      // daily
      //
      long long daily_value;
      bool daily_null;

      std::size_t version;
    };

    static id_type
    id (const object_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&, bool*);

    static void
    bind (sqlite::bind*,
          image_type&,
          sqlite::statement_kind);

    static void
    bind (sqlite::bind*, id_image_type&);

    static bool
    init (image_type&, const object_type&, sqlite::statement_kind);

    static void
    init (object_type&, const image_type&, database*);

    static void
    init (id_image_type&, const id_type&);

    typedef
    odb::pointer_cache_traits<pointer_type>
    pointer_cache_traits;
    typedef
    odb::reference_cache_traits<object_type>
    reference_cache_traits;

    typedef sqlite::object_statements<object_type> statements_type;

    typedef sqlite::query query_base_type;

    struct container_statement_cache_type;

    static const std::size_t column_count = 13UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);

    static void
    persist (database&, const object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static bool
    create_schema (database&, unsigned short pass, bool drop);

    public:
    static bool
    find_ (statements_type&, const id_type*);

    static void
    load_ (statements_type&, object_type&);
  };

  // Location
  //
  template <>
  struct class_traits< ::pio::Location >
  {
    static const class_kind kind = class_object;
  };

  template <typename A>
  struct pointer_query_columns< ::pio::Location, A >
  {
    // location
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    location_type_;

    static const location_type_ location;

    // link
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    link_type_;

    static const link_type_ link;

    // dir
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    dir_type_;

    static const dir_type_ dir;

    // offset
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    offset_type_;

    static const offset_type_ offset;

    // setback
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    setback_type_;

    static const setback_type_ setback;

    // zone
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    zone_type_;

    static const zone_type_ zone;
  };

  template <typename A>
  const typename pointer_query_columns< ::pio::Location, A >::location_type_
  pointer_query_columns< ::pio::Location, A >::
  location (A::table_name, "\"location\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Location, A >::link_type_
  pointer_query_columns< ::pio::Location, A >::
  link (A::table_name, "\"link\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Location, A >::dir_type_
  pointer_query_columns< ::pio::Location, A >::
  dir (A::table_name, "\"dir\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Location, A >::offset_type_
  pointer_query_columns< ::pio::Location, A >::
  offset (A::table_name, "\"offset\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Location, A >::setback_type_
  pointer_query_columns< ::pio::Location, A >::
  setback (A::table_name, "\"setback\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Location, A >::zone_type_
  pointer_query_columns< ::pio::Location, A >::
  zone (A::table_name, "\"zone\"", 0);

  template <>
  class access::object_traits< ::pio::Location >
  {
    public:
    typedef ::pio::Location object_type;
    typedef ::std::tr1::shared_ptr< ::pio::Location > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef int id_type;
    static const bool auto_id = false;

    struct id_image_type
    {
      long long id_value;
      bool id_null;

      std::size_t version;
    };

    static const bool abstract = false;

    struct image_type
    {
      // location
      //
      long long location_value;
      bool location_null;

      // link
      //
      long long link_value;
      bool link_null;

      // dir
      //
      long long dir_value;
      bool dir_null;

      // offset
      //
      double offset_value;
      bool offset_null;

      // setback
      //
      double setback_value;
      bool setback_null;

      // zone
      //
      long long zone_value;
      bool zone_null;

      std::size_t version;
    };

    static id_type
    id (const object_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&, bool*);

    static void
    bind (sqlite::bind*,
          image_type&,
          sqlite::statement_kind);

    static void
    bind (sqlite::bind*, id_image_type&);

    static bool
    init (image_type&, const object_type&, sqlite::statement_kind);

    static void
    init (object_type&, const image_type&, database*);

    static void
    init (id_image_type&, const id_type&);

    typedef
    odb::pointer_cache_traits<pointer_type>
    pointer_cache_traits;
    typedef
    odb::reference_cache_traits<object_type>
    reference_cache_traits;

    typedef sqlite::object_statements<object_type> statements_type;

    typedef sqlite::query query_base_type;

    struct container_statement_cache_type;

    static const std::size_t column_count = 6UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);

    static void
    persist (database&, const object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static bool
    create_schema (database&, unsigned short pass, bool drop);

    public:
    static bool
    find_ (statements_type&, const id_type*);

    static void
    load_ (statements_type&, object_type&);
  };

  // Access
  //
  template <>
  struct class_traits< ::pio::Access >
  {
    static const class_kind kind = class_object;
  };

  template <typename A>
  struct pointer_query_columns< ::pio::Access, A >
  {
    // auto_id
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        long unsigned int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    auto_id_type_;

    static const auto_id_type_ auto_id;

    // link
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    link_type_;

    static const link_type_ link;

    // from_id
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    from_id_type_;

    static const from_id_type_ from_id;

    // from_type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    from_type_type_;

    static const from_type_type_ from_type;

    // to_id
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    to_id_type_;

    static const to_id_type_ to_id;

    // to_type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    to_type_type_;

    static const to_type_type_ to_type;

    // dir
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    dir_type_;

    static const dir_type_ dir;

    // time
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    time_type_;

    static const time_type_ time;

    // cost
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    cost_type_;

    static const cost_type_ cost;
  };

  template <typename A>
  const typename pointer_query_columns< ::pio::Access, A >::auto_id_type_
  pointer_query_columns< ::pio::Access, A >::
  auto_id (A::table_name, "\"auto_id\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Access, A >::link_type_
  pointer_query_columns< ::pio::Access, A >::
  link (A::table_name, "\"link\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Access, A >::from_id_type_
  pointer_query_columns< ::pio::Access, A >::
  from_id (A::table_name, "\"from_id\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Access, A >::from_type_type_
  pointer_query_columns< ::pio::Access, A >::
  from_type (A::table_name, "\"from_type\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Access, A >::to_id_type_
  pointer_query_columns< ::pio::Access, A >::
  to_id (A::table_name, "\"to_id\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Access, A >::to_type_type_
  pointer_query_columns< ::pio::Access, A >::
  to_type (A::table_name, "\"to_type\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Access, A >::dir_type_
  pointer_query_columns< ::pio::Access, A >::
  dir (A::table_name, "\"dir\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Access, A >::time_type_
  pointer_query_columns< ::pio::Access, A >::
  time (A::table_name, "\"time\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Access, A >::cost_type_
  pointer_query_columns< ::pio::Access, A >::
  cost (A::table_name, "\"cost\"", 0);

  template <>
  class access::object_traits< ::pio::Access >
  {
    public:
    typedef ::pio::Access object_type;
    typedef ::std::tr1::shared_ptr< ::pio::Access > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef long unsigned int id_type;
    static const bool auto_id = true;

    struct id_image_type
    {
      long long id_value;
      bool id_null;

      std::size_t version;
    };

    static const bool abstract = false;

    struct image_type
    {
      // auto_id
      //
      long long auto_id_value;
      bool auto_id_null;

      // link
      //
      long long link_value;
      bool link_null;

      // from_id
      //
      long long from_id_value;
      bool from_id_null;

      // from_type
      //
      long long from_type_value;
      bool from_type_null;

      // to_id
      //
      long long to_id_value;
      bool to_id_null;

      // to_type
      //
      long long to_type_value;
      bool to_type_null;

      // dir
      //
      long long dir_value;
      bool dir_null;

      // time
      //
      double time_value;
      bool time_null;

      // cost
      //
      long long cost_value;
      bool cost_null;

      std::size_t version;
    };

    static id_type
    id (const object_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&, bool*);

    static void
    bind (sqlite::bind*,
          image_type&,
          sqlite::statement_kind);

    static void
    bind (sqlite::bind*, id_image_type&);

    static bool
    init (image_type&, const object_type&, sqlite::statement_kind);

    static void
    init (object_type&, const image_type&, database*);

    static void
    init (id_image_type&, const id_type&);

    typedef
    odb::pointer_cache_traits<pointer_type>
    pointer_cache_traits;
    typedef
    odb::reference_cache_traits<object_type>
    reference_cache_traits;

    typedef sqlite::object_statements<object_type> statements_type;

    typedef sqlite::query query_base_type;

    struct container_statement_cache_type;

    static const std::size_t column_count = 9UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static bool
    create_schema (database&, unsigned short pass, bool drop);

    public:
    static bool
    find_ (statements_type&, const id_type*);

    static void
    load_ (statements_type&, object_type&);
  };

  // Sign
  //
  template <>
  struct class_traits< ::pio::Sign >
  {
    static const class_kind kind = class_object;
  };

  template <typename A>
  struct pointer_query_columns< ::pio::Sign, A >
  {
    // auto_id
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        long unsigned int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    auto_id_type_;

    static const auto_id_type_ auto_id;

    // link
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    link_type_;

    static const link_type_ link;

    // dir
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    dir_type_;

    static const dir_type_ dir;

    // sign
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        ::std::string,
        sqlite::id_text >::query_type,
      sqlite::id_text >
    sign_type_;

    static const sign_type_ sign;
  };

  template <typename A>
  const typename pointer_query_columns< ::pio::Sign, A >::auto_id_type_
  pointer_query_columns< ::pio::Sign, A >::
  auto_id (A::table_name, "\"auto_id\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Sign, A >::link_type_
  pointer_query_columns< ::pio::Sign, A >::
  link (A::table_name, "\"link\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Sign, A >::dir_type_
  pointer_query_columns< ::pio::Sign, A >::
  dir (A::table_name, "\"dir\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Sign, A >::sign_type_
  pointer_query_columns< ::pio::Sign, A >::
  sign (A::table_name, "\"sign\"", 0);

  template <>
  class access::object_traits< ::pio::Sign >
  {
    public:
    typedef ::pio::Sign object_type;
    typedef ::std::tr1::shared_ptr< ::pio::Sign > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef long unsigned int id_type;
    static const bool auto_id = true;

    struct id_image_type
    {
      long long id_value;
      bool id_null;

      std::size_t version;
    };

    static const bool abstract = false;

    struct image_type
    {
      // auto_id
      //
      long long auto_id_value;
      bool auto_id_null;

      // link
      //
      long long link_value;
      bool link_null;

      // dir
      //
      long long dir_value;
      bool dir_null;

      // sign
      //
      details::buffer sign_value;
      std::size_t sign_size;
      bool sign_null;

      std::size_t version;
    };

    static id_type
    id (const object_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&, bool*);

    static void
    bind (sqlite::bind*,
          image_type&,
          sqlite::statement_kind);

    static void
    bind (sqlite::bind*, id_image_type&);

    static bool
    init (image_type&, const object_type&, sqlite::statement_kind);

    static void
    init (object_type&, const image_type&, database*);

    static void
    init (id_image_type&, const id_type&);

    typedef
    odb::pointer_cache_traits<pointer_type>
    pointer_cache_traits;
    typedef
    odb::reference_cache_traits<object_type>
    reference_cache_traits;

    typedef sqlite::object_statements<object_type> statements_type;

    typedef sqlite::query query_base_type;

    struct container_statement_cache_type;

    static const std::size_t column_count = 4UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static bool
    create_schema (database&, unsigned short pass, bool drop);

    public:
    static bool
    find_ (statements_type&, const id_type*);

    static void
    load_ (statements_type&, object_type&);
  };

  // Signal
  //
  template <>
  struct class_traits< ::pio::Signal >
  {
    static const class_kind kind = class_object;
  };

  template <typename A>
  struct pointer_query_columns< ::pio::Signal, A >
  {
    // signal
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    signal_type_;

    static const signal_type_ signal;

    // group
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    group_type_;

    static const group_type_ group;

    // times
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    times_type_;

    static const times_type_ times;

    // nodes
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    nodes_type_;

    static const nodes_type_ nodes;

    // type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        ::std::string,
        sqlite::id_text >::query_type,
      sqlite::id_text >
    type_type_;

    static const type_type_ type;

    // offset
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    offset_type_;

    static const offset_type_ offset;
  };

  template <typename A>
  const typename pointer_query_columns< ::pio::Signal, A >::signal_type_
  pointer_query_columns< ::pio::Signal, A >::
  signal (A::table_name, "\"signal\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Signal, A >::group_type_
  pointer_query_columns< ::pio::Signal, A >::
  group (A::table_name, "\"group\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Signal, A >::times_type_
  pointer_query_columns< ::pio::Signal, A >::
  times (A::table_name, "\"times\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Signal, A >::nodes_type_
  pointer_query_columns< ::pio::Signal, A >::
  nodes (A::table_name, "\"nodes\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Signal, A >::type_type_
  pointer_query_columns< ::pio::Signal, A >::
  type (A::table_name, "\"type\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Signal, A >::offset_type_
  pointer_query_columns< ::pio::Signal, A >::
  offset (A::table_name, "\"offset\"", 0);

  template <>
  class access::object_traits< ::pio::Signal >
  {
    public:
    typedef ::pio::Signal object_type;
    typedef ::std::tr1::shared_ptr< ::pio::Signal > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef int id_type;
    static const bool auto_id = false;

    struct id_image_type
    {
      long long id_value;
      bool id_null;

      std::size_t version;
    };

    static const bool abstract = false;

    struct image_type
    {
      // signal
      //
      long long signal_value;
      bool signal_null;

      // group
      //
      long long group_value;
      bool group_null;

      // times
      //
      long long times_value;
      bool times_null;

      // nodes
      //
      long long nodes_value;
      bool nodes_null;

      // type
      //
      details::buffer type_value;
      std::size_t type_size;
      bool type_null;

      // offset
      //
      long long offset_value;
      bool offset_null;

      std::size_t version;
    };

    // nested_records
    //
    struct nested_records_traits
    {
      static const std::size_t id_column_count = 1UL;
      static const std::size_t cond_column_count = 1UL;
      static const std::size_t data_column_count = 6UL;

      static const char insert_one_statement[];
      static const char select_all_statement[];
      static const char delete_all_statement[];

      typedef ::std::vector< ::pio::signal_time > container_type;
      typedef
      odb::access::container_traits<container_type>
      container_traits_type;
      typedef container_traits_type::index_type index_type;
      typedef container_traits_type::value_type value_type;

      typedef ordered_functions<index_type, value_type> functions_type;
      typedef sqlite::container_statements< nested_records_traits > statements_type;

      struct cond_image_type
      {
        // index
        //
        long long index_value;
        bool index_null;

        std::size_t version;
      };

      struct data_image_type
      {
        // index
        //
        long long index_value;
        bool index_null;

        // value
        //
        composite_value_traits< value_type >::image_type value_value;

        std::size_t version;
      };

      static void
      bind (sqlite::bind*,
            const sqlite::bind* id,
            std::size_t id_size,
            cond_image_type&);

      static void
      bind (sqlite::bind*,
            const sqlite::bind* id,
            std::size_t id_size,
            data_image_type&);

      static void
      grow (data_image_type&, bool*);

      static void
      init (data_image_type&, index_type, const value_type&);

      static void
      init (index_type&, value_type&, const data_image_type&, database*);

      static void
      insert_one (index_type, const value_type&, void*);

      static bool
      load_all (index_type&, value_type&, void*);

      static void
      delete_all (void*);

      static void
      persist (const container_type&,
               const sqlite::binding& id,
               statements_type&);

      static void
      load (container_type&,
            const sqlite::binding& id,
            statements_type&);

      static void
      update (const container_type&,
              const sqlite::binding& id,
              statements_type&);

      static void
      erase (const sqlite::binding& id, statements_type&);
    };

    static id_type
    id (const object_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&, bool*);

    static void
    bind (sqlite::bind*,
          image_type&,
          sqlite::statement_kind);

    static void
    bind (sqlite::bind*, id_image_type&);

    static bool
    init (image_type&, const object_type&, sqlite::statement_kind);

    static void
    init (object_type&, const image_type&, database*);

    static void
    init (id_image_type&, const id_type&);

    typedef
    odb::pointer_cache_traits<pointer_type>
    pointer_cache_traits;
    typedef
    odb::reference_cache_traits<object_type>
    reference_cache_traits;

    typedef sqlite::object_statements<object_type> statements_type;

    typedef sqlite::query query_base_type;

    struct container_statement_cache_type;

    static const std::size_t column_count = 6UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);

    static void
    persist (database&, const object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static bool
    create_schema (database&, unsigned short pass, bool drop);

    public:
    static bool
    find_ (statements_type&, const id_type*);

    static void
    load_ (statements_type&, object_type&);
  };

  // Timing
  //
  template <>
  struct class_traits< ::pio::Timing >
  {
    static const class_kind kind = class_object;
  };

  template <typename A>
  struct pointer_query_columns< ::pio::Timing, A >
  {
    // auto_id
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        long unsigned int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    auto_id_type_;

    static const auto_id_type_ auto_id;

    // signal
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    signal_type_;

    static const signal_type_ signal;

    // timing
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    timing_type_;

    static const timing_type_ timing;

    // type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    type_type_;

    static const type_type_ type;

    // cycle
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    cycle_type_;

    static const cycle_type_ cycle;

    // offset
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    offset_type_;

    static const offset_type_ offset;

    // phases
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    phases_type_;

    static const phases_type_ phases;
  };

  template <typename A>
  const typename pointer_query_columns< ::pio::Timing, A >::auto_id_type_
  pointer_query_columns< ::pio::Timing, A >::
  auto_id (A::table_name, "\"auto_id\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Timing, A >::signal_type_
  pointer_query_columns< ::pio::Timing, A >::
  signal (A::table_name, "\"signal\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Timing, A >::timing_type_
  pointer_query_columns< ::pio::Timing, A >::
  timing (A::table_name, "\"timing\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Timing, A >::type_type_
  pointer_query_columns< ::pio::Timing, A >::
  type (A::table_name, "\"type\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Timing, A >::cycle_type_
  pointer_query_columns< ::pio::Timing, A >::
  cycle (A::table_name, "\"cycle\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Timing, A >::offset_type_
  pointer_query_columns< ::pio::Timing, A >::
  offset (A::table_name, "\"offset\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Timing, A >::phases_type_
  pointer_query_columns< ::pio::Timing, A >::
  phases (A::table_name, "\"phases\"", 0);

  template <>
  class access::object_traits< ::pio::Timing >
  {
    public:
    typedef ::pio::Timing object_type;
    typedef ::std::tr1::shared_ptr< ::pio::Timing > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef long unsigned int id_type;
    static const bool auto_id = true;

    struct id_image_type
    {
      long long id_value;
      bool id_null;

      std::size_t version;
    };

    static const bool abstract = false;

    struct image_type
    {
      // auto_id
      //
      long long auto_id_value;
      bool auto_id_null;

      // signal
      //
      long long signal_value;
      bool signal_null;

      // timing
      //
      long long timing_value;
      bool timing_null;

      // type
      //
      long long type_value;
      bool type_null;

      // cycle
      //
      long long cycle_value;
      bool cycle_null;

      // offset
      //
      long long offset_value;
      bool offset_null;

      // phases
      //
      long long phases_value;
      bool phases_null;

      std::size_t version;
    };

    // nested_records
    //
    struct nested_records_traits
    {
      static const std::size_t id_column_count = 1UL;
      static const std::size_t cond_column_count = 1UL;
      static const std::size_t data_column_count = 11UL;

      static const char insert_one_statement[];
      static const char select_all_statement[];
      static const char delete_all_statement[];

      typedef ::std::vector< ::pio::timing_phase > container_type;
      typedef
      odb::access::container_traits<container_type>
      container_traits_type;
      typedef container_traits_type::index_type index_type;
      typedef container_traits_type::value_type value_type;

      typedef ordered_functions<index_type, value_type> functions_type;
      typedef sqlite::container_statements< nested_records_traits > statements_type;

      struct cond_image_type
      {
        // index
        //
        long long index_value;
        bool index_null;

        std::size_t version;
      };

      struct data_image_type
      {
        // index
        //
        long long index_value;
        bool index_null;

        // value
        //
        composite_value_traits< value_type >::image_type value_value;

        std::size_t version;
      };

      static void
      bind (sqlite::bind*,
            const sqlite::bind* id,
            std::size_t id_size,
            cond_image_type&);

      static void
      bind (sqlite::bind*,
            const sqlite::bind* id,
            std::size_t id_size,
            data_image_type&);

      static void
      grow (data_image_type&, bool*);

      static void
      init (data_image_type&, index_type, const value_type&);

      static void
      init (index_type&, value_type&, const data_image_type&, database*);

      static void
      insert_one (index_type, const value_type&, void*);

      static bool
      load_all (index_type&, value_type&, void*);

      static void
      delete_all (void*);

      static void
      persist (const container_type&,
               const sqlite::binding& id,
               statements_type&);

      static void
      load (container_type&,
            const sqlite::binding& id,
            statements_type&);

      static void
      update (const container_type&,
              const sqlite::binding& id,
              statements_type&);

      static void
      erase (const sqlite::binding& id, statements_type&);
    };

    static id_type
    id (const object_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&, bool*);

    static void
    bind (sqlite::bind*,
          image_type&,
          sqlite::statement_kind);

    static void
    bind (sqlite::bind*, id_image_type&);

    static bool
    init (image_type&, const object_type&, sqlite::statement_kind);

    static void
    init (object_type&, const image_type&, database*);

    static void
    init (id_image_type&, const id_type&);

    typedef
    odb::pointer_cache_traits<pointer_type>
    pointer_cache_traits;
    typedef
    odb::reference_cache_traits<object_type>
    reference_cache_traits;

    typedef sqlite::object_statements<object_type> statements_type;

    typedef sqlite::query query_base_type;

    struct container_statement_cache_type;

    static const std::size_t column_count = 7UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static bool
    create_schema (database&, unsigned short pass, bool drop);

    public:
    static bool
    find_ (statements_type&, const id_type*);

    static void
    load_ (statements_type&, object_type&);
  };

  // Phasing
  //
  template <>
  struct class_traits< ::pio::Phasing >
  {
    static const class_kind kind = class_object;
  };

  template <typename A>
  struct pointer_query_columns< ::pio::Phasing, A >
  {
    // auto_id
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        long unsigned int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    auto_id_type_;

    static const auto_id_type_ auto_id;

    // signal
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    signal_type_;

    static const signal_type_ signal;

    // phasing
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    phasing_type_;

    static const phasing_type_ phasing;

    // phase
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    phase_type_;

    static const phase_type_ phase;

    // detectors
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        ::std::string,
        sqlite::id_text >::query_type,
      sqlite::id_text >
    detectors_type_;

    static const detectors_type_ detectors;

    // movements
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    movements_type_;

    static const movements_type_ movements;
  };

  template <typename A>
  const typename pointer_query_columns< ::pio::Phasing, A >::auto_id_type_
  pointer_query_columns< ::pio::Phasing, A >::
  auto_id (A::table_name, "\"auto_id\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Phasing, A >::signal_type_
  pointer_query_columns< ::pio::Phasing, A >::
  signal (A::table_name, "\"signal\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Phasing, A >::phasing_type_
  pointer_query_columns< ::pio::Phasing, A >::
  phasing (A::table_name, "\"phasing\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Phasing, A >::phase_type_
  pointer_query_columns< ::pio::Phasing, A >::
  phase (A::table_name, "\"phase\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Phasing, A >::detectors_type_
  pointer_query_columns< ::pio::Phasing, A >::
  detectors (A::table_name, "\"detectors\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Phasing, A >::movements_type_
  pointer_query_columns< ::pio::Phasing, A >::
  movements (A::table_name, "\"movements\"", 0);

  template <>
  class access::object_traits< ::pio::Phasing >
  {
    public:
    typedef ::pio::Phasing object_type;
    typedef ::std::tr1::shared_ptr< ::pio::Phasing > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef long unsigned int id_type;
    static const bool auto_id = true;

    struct id_image_type
    {
      long long id_value;
      bool id_null;

      std::size_t version;
    };

    static const bool abstract = false;

    struct image_type
    {
      // auto_id
      //
      long long auto_id_value;
      bool auto_id_null;

      // signal
      //
      long long signal_value;
      bool signal_null;

      // phasing
      //
      long long phasing_value;
      bool phasing_null;

      // phase
      //
      long long phase_value;
      bool phase_null;

      // detectors
      //
      details::buffer detectors_value;
      std::size_t detectors_size;
      bool detectors_null;

      // movements
      //
      long long movements_value;
      bool movements_null;

      std::size_t version;
    };

    // nested_records
    //
    struct nested_records_traits
    {
      static const std::size_t id_column_count = 1UL;
      static const std::size_t cond_column_count = 1UL;
      static const std::size_t data_column_count = 7UL;

      static const char insert_one_statement[];
      static const char select_all_statement[];
      static const char delete_all_statement[];

      typedef ::std::vector< ::pio::phase_movement > container_type;
      typedef
      odb::access::container_traits<container_type>
      container_traits_type;
      typedef container_traits_type::index_type index_type;
      typedef container_traits_type::value_type value_type;

      typedef ordered_functions<index_type, value_type> functions_type;
      typedef sqlite::container_statements< nested_records_traits > statements_type;

      struct cond_image_type
      {
        // index
        //
        long long index_value;
        bool index_null;

        std::size_t version;
      };

      struct data_image_type
      {
        // index
        //
        long long index_value;
        bool index_null;

        // value
        //
        composite_value_traits< value_type >::image_type value_value;

        std::size_t version;
      };

      static void
      bind (sqlite::bind*,
            const sqlite::bind* id,
            std::size_t id_size,
            cond_image_type&);

      static void
      bind (sqlite::bind*,
            const sqlite::bind* id,
            std::size_t id_size,
            data_image_type&);

      static void
      grow (data_image_type&, bool*);

      static void
      init (data_image_type&, index_type, const value_type&);

      static void
      init (index_type&, value_type&, const data_image_type&, database*);

      static void
      insert_one (index_type, const value_type&, void*);

      static bool
      load_all (index_type&, value_type&, void*);

      static void
      delete_all (void*);

      static void
      persist (const container_type&,
               const sqlite::binding& id,
               statements_type&);

      static void
      load (container_type&,
            const sqlite::binding& id,
            statements_type&);

      static void
      update (const container_type&,
              const sqlite::binding& id,
              statements_type&);

      static void
      erase (const sqlite::binding& id, statements_type&);
    };

    static id_type
    id (const object_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&, bool*);

    static void
    bind (sqlite::bind*,
          image_type&,
          sqlite::statement_kind);

    static void
    bind (sqlite::bind*, id_image_type&);

    static bool
    init (image_type&, const object_type&, sqlite::statement_kind);

    static void
    init (object_type&, const image_type&, database*);

    static void
    init (id_image_type&, const id_type&);

    typedef
    odb::pointer_cache_traits<pointer_type>
    pointer_cache_traits;
    typedef
    odb::reference_cache_traits<object_type>
    reference_cache_traits;

    typedef sqlite::object_statements<object_type> statements_type;

    typedef sqlite::query query_base_type;

    struct container_statement_cache_type;

    static const std::size_t column_count = 6UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static bool
    create_schema (database&, unsigned short pass, bool drop);

    public:
    static bool
    find_ (statements_type&, const id_type*);

    static void
    load_ (statements_type&, object_type&);
  };

  // Detector
  //
  template <>
  struct class_traits< ::pio::Detector >
  {
    static const class_kind kind = class_object;
  };

  template <typename A>
  struct pointer_query_columns< ::pio::Detector, A >
  {
    // detector
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    detector_type_;

    static const detector_type_ detector;

    // link
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    link_type_;

    static const link_type_ link;

    // dir
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    dir_type_;

    static const dir_type_ dir;

    // offset
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    offset_type_;

    static const offset_type_ offset;

    // length
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    length_type_;

    static const length_type_ length;

    // lanes
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    lanes_type_;

    static const lanes_type_ lanes;

    // type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    type_type_;

    static const type_type_ type;

    // use
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    use_type_;

    static const use_type_ use;

    // low
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    low_type_;

    static const low_type_ low;

    // high
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    high_type_;

    static const high_type_ high;
  };

  template <typename A>
  const typename pointer_query_columns< ::pio::Detector, A >::detector_type_
  pointer_query_columns< ::pio::Detector, A >::
  detector (A::table_name, "\"detector\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Detector, A >::link_type_
  pointer_query_columns< ::pio::Detector, A >::
  link (A::table_name, "\"link\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Detector, A >::dir_type_
  pointer_query_columns< ::pio::Detector, A >::
  dir (A::table_name, "\"dir\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Detector, A >::offset_type_
  pointer_query_columns< ::pio::Detector, A >::
  offset (A::table_name, "\"offset\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Detector, A >::length_type_
  pointer_query_columns< ::pio::Detector, A >::
  length (A::table_name, "\"length\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Detector, A >::lanes_type_
  pointer_query_columns< ::pio::Detector, A >::
  lanes (A::table_name, "\"lanes\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Detector, A >::type_type_
  pointer_query_columns< ::pio::Detector, A >::
  type (A::table_name, "\"type\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Detector, A >::use_type_
  pointer_query_columns< ::pio::Detector, A >::
  use (A::table_name, "\"use\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Detector, A >::low_type_
  pointer_query_columns< ::pio::Detector, A >::
  low (A::table_name, "\"low\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Detector, A >::high_type_
  pointer_query_columns< ::pio::Detector, A >::
  high (A::table_name, "\"high\"", 0);

  template <>
  class access::object_traits< ::pio::Detector >
  {
    public:
    typedef ::pio::Detector object_type;
    typedef ::std::tr1::shared_ptr< ::pio::Detector > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef int id_type;
    static const bool auto_id = false;

    struct id_image_type
    {
      long long id_value;
      bool id_null;

      std::size_t version;
    };

    static const bool abstract = false;

    struct image_type
    {
      // detector
      //
      long long detector_value;
      bool detector_null;

      // link
      //
      long long link_value;
      bool link_null;

      // dir
      //
      long long dir_value;
      bool dir_null;

      // offset
      //
      double offset_value;
      bool offset_null;

      // length
      //
      double length_value;
      bool length_null;

      // lanes
      //
      long long lanes_value;
      bool lanes_null;

      // type
      //
      long long type_value;
      bool type_null;

      // use
      //
      long long use_value;
      bool use_null;

      // low
      //
      long long low_value;
      bool low_null;

      // high
      //
      long long high_value;
      bool high_null;

      std::size_t version;
    };

    static id_type
    id (const object_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&, bool*);

    static void
    bind (sqlite::bind*,
          image_type&,
          sqlite::statement_kind);

    static void
    bind (sqlite::bind*, id_image_type&);

    static bool
    init (image_type&, const object_type&, sqlite::statement_kind);

    static void
    init (object_type&, const image_type&, database*);

    static void
    init (id_image_type&, const id_type&);

    typedef
    odb::pointer_cache_traits<pointer_type>
    pointer_cache_traits;
    typedef
    odb::reference_cache_traits<object_type>
    reference_cache_traits;

    typedef sqlite::object_statements<object_type> statements_type;

    typedef sqlite::query query_base_type;

    struct container_statement_cache_type;

    static const std::size_t column_count = 10UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);

    static void
    persist (database&, const object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static bool
    create_schema (database&, unsigned short pass, bool drop);

    public:
    static bool
    find_ (statements_type&, const id_type*);

    static void
    load_ (statements_type&, object_type&);
  };

  // Stop
  //
  template <>
  struct class_traits< ::pio::Stop >
  {
    static const class_kind kind = class_object;
  };

  template <typename A>
  struct pointer_query_columns< ::pio::Stop, A >
  {
    // stop
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    stop_type_;

    static const stop_type_ stop;

    // name
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        ::std::string,
        sqlite::id_text >::query_type,
      sqlite::id_text >
    name_type_;

    static const name_type_ name;

    // link
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    link_type_;

    static const link_type_ link;

    // dir
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    dir_type_;

    static const dir_type_ dir;

    // offset
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    offset_type_;

    static const offset_type_ offset;

    // use
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    use_type_;

    static const use_type_ use;

    // type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    type_type_;

    static const type_type_ type;

    // space
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    space_type_;

    static const space_type_ space;
  };

  template <typename A>
  const typename pointer_query_columns< ::pio::Stop, A >::stop_type_
  pointer_query_columns< ::pio::Stop, A >::
  stop (A::table_name, "\"stop\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Stop, A >::name_type_
  pointer_query_columns< ::pio::Stop, A >::
  name (A::table_name, "\"name\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Stop, A >::link_type_
  pointer_query_columns< ::pio::Stop, A >::
  link (A::table_name, "\"link\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Stop, A >::dir_type_
  pointer_query_columns< ::pio::Stop, A >::
  dir (A::table_name, "\"dir\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Stop, A >::offset_type_
  pointer_query_columns< ::pio::Stop, A >::
  offset (A::table_name, "\"offset\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Stop, A >::use_type_
  pointer_query_columns< ::pio::Stop, A >::
  use (A::table_name, "\"use\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Stop, A >::type_type_
  pointer_query_columns< ::pio::Stop, A >::
  type (A::table_name, "\"type\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Stop, A >::space_type_
  pointer_query_columns< ::pio::Stop, A >::
  space (A::table_name, "\"space\"", 0);

  template <>
  class access::object_traits< ::pio::Stop >
  {
    public:
    typedef ::pio::Stop object_type;
    typedef ::std::tr1::shared_ptr< ::pio::Stop > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef int id_type;
    static const bool auto_id = false;

    struct id_image_type
    {
      long long id_value;
      bool id_null;

      std::size_t version;
    };

    static const bool abstract = false;

    struct image_type
    {
      // stop
      //
      long long stop_value;
      bool stop_null;

      // name
      //
      details::buffer name_value;
      std::size_t name_size;
      bool name_null;

      // link
      //
      long long link_value;
      bool link_null;

      // dir
      //
      long long dir_value;
      bool dir_null;

      // offset
      //
      double offset_value;
      bool offset_null;

      // use
      //
      long long use_value;
      bool use_null;

      // type
      //
      long long type_value;
      bool type_null;

      // space
      //
      long long space_value;
      bool space_null;

      std::size_t version;
    };

    static id_type
    id (const object_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&, bool*);

    static void
    bind (sqlite::bind*,
          image_type&,
          sqlite::statement_kind);

    static void
    bind (sqlite::bind*, id_image_type&);

    static bool
    init (image_type&, const object_type&, sqlite::statement_kind);

    static void
    init (object_type&, const image_type&, database*);

    static void
    init (id_image_type&, const id_type&);

    typedef
    odb::pointer_cache_traits<pointer_type>
    pointer_cache_traits;
    typedef
    odb::reference_cache_traits<object_type>
    reference_cache_traits;

    typedef sqlite::object_statements<object_type> statements_type;

    typedef sqlite::query query_base_type;

    struct container_statement_cache_type;

    static const std::size_t column_count = 8UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);

    static void
    persist (database&, const object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static bool
    create_schema (database&, unsigned short pass, bool drop);

    public:
    static bool
    find_ (statements_type&, const id_type*);

    static void
    load_ (statements_type&, object_type&);
  };

  // Fare
  //
  template <>
  struct class_traits< ::pio::Fare >
  {
    static const class_kind kind = class_object;
  };

  template <typename A>
  struct pointer_query_columns< ::pio::Fare, A >
  {
    // from_zone
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    from_zone_type_;

    static const from_zone_type_ from_zone;

    // to_zone
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    to_zone_type_;

    static const to_zone_type_ to_zone;

    // from_mode
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    from_mode_type_;

    static const from_mode_type_ from_mode;

    // to_mode
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    to_mode_type_;

    static const to_mode_type_ to_mode;

    // period
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    period_type_;

    static const period_type_ period;

    // type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    type_type_;

    static const type_type_ type;

    // fare
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    fare_type_;

    static const fare_type_ fare;
  };

  template <typename A>
  const typename pointer_query_columns< ::pio::Fare, A >::from_zone_type_
  pointer_query_columns< ::pio::Fare, A >::
  from_zone (A::table_name, "\"from_zone\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Fare, A >::to_zone_type_
  pointer_query_columns< ::pio::Fare, A >::
  to_zone (A::table_name, "\"to_zone\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Fare, A >::from_mode_type_
  pointer_query_columns< ::pio::Fare, A >::
  from_mode (A::table_name, "\"from_mode\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Fare, A >::to_mode_type_
  pointer_query_columns< ::pio::Fare, A >::
  to_mode (A::table_name, "\"to_mode\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Fare, A >::period_type_
  pointer_query_columns< ::pio::Fare, A >::
  period (A::table_name, "\"period\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Fare, A >::type_type_
  pointer_query_columns< ::pio::Fare, A >::
  type (A::table_name, "\"type\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Fare, A >::fare_type_
  pointer_query_columns< ::pio::Fare, A >::
  fare (A::table_name, "\"fare\"", 0);

  template <>
  class access::object_traits< ::pio::Fare >
  {
    public:
    typedef ::pio::Fare object_type;
    typedef ::std::tr1::shared_ptr< ::pio::Fare > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef int id_type;
    static const bool auto_id = false;

    struct id_image_type
    {
      long long id_value;
      bool id_null;

      std::size_t version;
    };

    static const bool abstract = false;

    struct image_type
    {
      // from_zone
      //
      long long from_zone_value;
      bool from_zone_null;

      // to_zone
      //
      long long to_zone_value;
      bool to_zone_null;

      // from_mode
      //
      long long from_mode_value;
      bool from_mode_null;

      // to_mode
      //
      long long to_mode_value;
      bool to_mode_null;

      // period
      //
      long long period_value;
      bool period_null;

      // type
      //
      long long type_value;
      bool type_null;

      // fare
      //
      long long fare_value;
      bool fare_null;

      std::size_t version;
    };

    static id_type
    id (const object_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&, bool*);

    static void
    bind (sqlite::bind*,
          image_type&,
          sqlite::statement_kind);

    static void
    bind (sqlite::bind*, id_image_type&);

    static bool
    init (image_type&, const object_type&, sqlite::statement_kind);

    static void
    init (object_type&, const image_type&, database*);

    static void
    init (id_image_type&, const id_type&);

    typedef
    odb::pointer_cache_traits<pointer_type>
    pointer_cache_traits;
    typedef
    odb::reference_cache_traits<object_type>
    reference_cache_traits;

    typedef sqlite::object_statements<object_type> statements_type;

    typedef sqlite::query query_base_type;

    struct container_statement_cache_type;

    static const std::size_t column_count = 7UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);

    static void
    persist (database&, const object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static bool
    create_schema (database&, unsigned short pass, bool drop);

    public:
    static bool
    find_ (statements_type&, const id_type*);

    static void
    load_ (statements_type&, object_type&);
  };

  // Line
  //
  template <>
  struct class_traits< ::pio::Line >
  {
    static const class_kind kind = class_object;
  };

  template <typename A>
  struct pointer_query_columns< ::pio::Line, A >
  {
    // auto_id
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        long unsigned int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    auto_id_type_;

    static const auto_id_type_ auto_id;

    // route
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    route_type_;

    static const route_type_ route;

    // stops
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    stops_type_;

    static const stops_type_ stops;

    // mode
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    mode_type_;

    static const mode_type_ mode;

    // type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    type_type_;

    static const type_type_ type;

    // name
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        ::std::string,
        sqlite::id_text >::query_type,
      sqlite::id_text >
    name_type_;

    static const name_type_ name;

    // stop
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    stop_type_;

    static const stop_type_ stop;

    // zone
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    zone_type_;

    static const zone_type_ zone;

    // flag
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    flag_type_;

    static const flag_type_ flag;
  };

  template <typename A>
  const typename pointer_query_columns< ::pio::Line, A >::auto_id_type_
  pointer_query_columns< ::pio::Line, A >::
  auto_id (A::table_name, "\"auto_id\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Line, A >::route_type_
  pointer_query_columns< ::pio::Line, A >::
  route (A::table_name, "\"route\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Line, A >::stops_type_
  pointer_query_columns< ::pio::Line, A >::
  stops (A::table_name, "\"stops\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Line, A >::mode_type_
  pointer_query_columns< ::pio::Line, A >::
  mode (A::table_name, "\"mode\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Line, A >::type_type_
  pointer_query_columns< ::pio::Line, A >::
  type (A::table_name, "\"type\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Line, A >::name_type_
  pointer_query_columns< ::pio::Line, A >::
  name (A::table_name, "\"name\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Line, A >::stop_type_
  pointer_query_columns< ::pio::Line, A >::
  stop (A::table_name, "\"stop\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Line, A >::zone_type_
  pointer_query_columns< ::pio::Line, A >::
  zone (A::table_name, "\"zone\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Line, A >::flag_type_
  pointer_query_columns< ::pio::Line, A >::
  flag (A::table_name, "\"flag\"", 0);

  template <>
  class access::object_traits< ::pio::Line >
  {
    public:
    typedef ::pio::Line object_type;
    typedef ::std::tr1::shared_ptr< ::pio::Line > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef long unsigned int id_type;
    static const bool auto_id = true;

    struct id_image_type
    {
      long long id_value;
      bool id_null;

      std::size_t version;
    };

    static const bool abstract = false;

    struct image_type
    {
      // auto_id
      //
      long long auto_id_value;
      bool auto_id_null;

      // route
      //
      long long route_value;
      bool route_null;

      // stops
      //
      long long stops_value;
      bool stops_null;

      // mode
      //
      long long mode_value;
      bool mode_null;

      // type
      //
      long long type_value;
      bool type_null;

      // name
      //
      details::buffer name_value;
      std::size_t name_size;
      bool name_null;

      // stop
      //
      long long stop_value;
      bool stop_null;

      // zone
      //
      long long zone_value;
      bool zone_null;

      // flag
      //
      long long flag_value;
      bool flag_null;

      std::size_t version;
    };

    static id_type
    id (const object_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&, bool*);

    static void
    bind (sqlite::bind*,
          image_type&,
          sqlite::statement_kind);

    static void
    bind (sqlite::bind*, id_image_type&);

    static bool
    init (image_type&, const object_type&, sqlite::statement_kind);

    static void
    init (object_type&, const image_type&, database*);

    static void
    init (id_image_type&, const id_type&);

    typedef
    odb::pointer_cache_traits<pointer_type>
    pointer_cache_traits;
    typedef
    odb::reference_cache_traits<object_type>
    reference_cache_traits;

    typedef sqlite::object_statements<object_type> statements_type;

    typedef sqlite::query query_base_type;

    struct container_statement_cache_type;

    static const std::size_t column_count = 9UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static bool
    create_schema (database&, unsigned short pass, bool drop);

    public:
    static bool
    find_ (statements_type&, const id_type*);

    static void
    load_ (statements_type&, object_type&);
  };

  // Schedule
  //
  template <>
  struct class_traits< ::pio::Schedule >
  {
    static const class_kind kind = class_object;
  };

  template <typename A>
  struct pointer_query_columns< ::pio::Schedule, A >
  {
    // auto_id
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        long unsigned int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    auto_id_type_;

    static const auto_id_type_ auto_id;

    // route
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    route_type_;

    static const route_type_ route;

    // stops
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    stops_type_;

    static const stops_type_ stops;

    // stop
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    stop_type_;

    static const stop_type_ stop;
  };

  template <typename A>
  const typename pointer_query_columns< ::pio::Schedule, A >::auto_id_type_
  pointer_query_columns< ::pio::Schedule, A >::
  auto_id (A::table_name, "\"auto_id\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Schedule, A >::route_type_
  pointer_query_columns< ::pio::Schedule, A >::
  route (A::table_name, "\"route\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Schedule, A >::stops_type_
  pointer_query_columns< ::pio::Schedule, A >::
  stops (A::table_name, "\"stops\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Schedule, A >::stop_type_
  pointer_query_columns< ::pio::Schedule, A >::
  stop (A::table_name, "\"stop\"", 0);

  template <>
  class access::object_traits< ::pio::Schedule >
  {
    public:
    typedef ::pio::Schedule object_type;
    typedef ::std::tr1::shared_ptr< ::pio::Schedule > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef long unsigned int id_type;
    static const bool auto_id = true;

    struct id_image_type
    {
      long long id_value;
      bool id_null;

      std::size_t version;
    };

    static const bool abstract = false;

    struct image_type
    {
      // auto_id
      //
      long long auto_id_value;
      bool auto_id_null;

      // route
      //
      long long route_value;
      bool route_null;

      // stops
      //
      long long stops_value;
      bool stops_null;

      // stop
      //
      long long stop_value;
      bool stop_null;

      std::size_t version;
    };

    static id_type
    id (const object_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&, bool*);

    static void
    bind (sqlite::bind*,
          image_type&,
          sqlite::statement_kind);

    static void
    bind (sqlite::bind*, id_image_type&);

    static bool
    init (image_type&, const object_type&, sqlite::statement_kind);

    static void
    init (object_type&, const image_type&, database*);

    static void
    init (id_image_type&, const id_type&);

    typedef
    odb::pointer_cache_traits<pointer_type>
    pointer_cache_traits;
    typedef
    odb::reference_cache_traits<object_type>
    reference_cache_traits;

    typedef sqlite::object_statements<object_type> statements_type;

    typedef sqlite::query query_base_type;

    struct container_statement_cache_type;

    static const std::size_t column_count = 4UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static bool
    create_schema (database&, unsigned short pass, bool drop);

    public:
    static bool
    find_ (statements_type&, const id_type*);

    static void
    load_ (statements_type&, object_type&);
  };

  // Driver
  //
  template <>
  struct class_traits< ::pio::Driver >
  {
    static const class_kind kind = class_object;
  };

  template <typename A>
  struct pointer_query_columns< ::pio::Driver, A >
  {
    // auto_id
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        long unsigned int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    auto_id_type_;

    static const auto_id_type_ auto_id;

    // route
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    route_type_;

    static const route_type_ route;

    // links
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    links_type_;

    static const links_type_ links;

    // type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    type_type_;

    static const type_type_ type;

    // subtype
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    subtype_type_;

    static const subtype_type_ subtype;

    // link
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    link_type_;

    static const link_type_ link;

    // dir
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    dir_type_;

    static const dir_type_ dir;
  };

  template <typename A>
  const typename pointer_query_columns< ::pio::Driver, A >::auto_id_type_
  pointer_query_columns< ::pio::Driver, A >::
  auto_id (A::table_name, "\"auto_id\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Driver, A >::route_type_
  pointer_query_columns< ::pio::Driver, A >::
  route (A::table_name, "\"route\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Driver, A >::links_type_
  pointer_query_columns< ::pio::Driver, A >::
  links (A::table_name, "\"links\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Driver, A >::type_type_
  pointer_query_columns< ::pio::Driver, A >::
  type (A::table_name, "\"type\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Driver, A >::subtype_type_
  pointer_query_columns< ::pio::Driver, A >::
  subtype (A::table_name, "\"subtype\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Driver, A >::link_type_
  pointer_query_columns< ::pio::Driver, A >::
  link (A::table_name, "\"link\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Driver, A >::dir_type_
  pointer_query_columns< ::pio::Driver, A >::
  dir (A::table_name, "\"dir\"", 0);

  template <>
  class access::object_traits< ::pio::Driver >
  {
    public:
    typedef ::pio::Driver object_type;
    typedef ::std::tr1::shared_ptr< ::pio::Driver > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef long unsigned int id_type;
    static const bool auto_id = true;

    struct id_image_type
    {
      long long id_value;
      bool id_null;

      std::size_t version;
    };

    static const bool abstract = false;

    struct image_type
    {
      // auto_id
      //
      long long auto_id_value;
      bool auto_id_null;

      // route
      //
      long long route_value;
      bool route_null;

      // links
      //
      long long links_value;
      bool links_null;

      // type
      //
      long long type_value;
      bool type_null;

      // subtype
      //
      long long subtype_value;
      bool subtype_null;

      // link
      //
      long long link_value;
      bool link_null;

      // dir
      //
      long long dir_value;
      bool dir_null;

      std::size_t version;
    };

    static id_type
    id (const object_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&, bool*);

    static void
    bind (sqlite::bind*,
          image_type&,
          sqlite::statement_kind);

    static void
    bind (sqlite::bind*, id_image_type&);

    static bool
    init (image_type&, const object_type&, sqlite::statement_kind);

    static void
    init (object_type&, const image_type&, database*);

    static void
    init (id_image_type&, const id_type&);

    typedef
    odb::pointer_cache_traits<pointer_type>
    pointer_cache_traits;
    typedef
    odb::reference_cache_traits<object_type>
    reference_cache_traits;

    typedef sqlite::object_statements<object_type> statements_type;

    typedef sqlite::query query_base_type;

    struct container_statement_cache_type;

    static const std::size_t column_count = 7UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static bool
    create_schema (database&, unsigned short pass, bool drop);

    public:
    static bool
    find_ (statements_type&, const id_type*);

    static void
    load_ (statements_type&, object_type&);
  };

  // Route_Nodes
  //
  template <>
  struct class_traits< ::pio::Route_Nodes >
  {
    static const class_kind kind = class_object;
  };

  template <typename A>
  struct pointer_query_columns< ::pio::Route_Nodes, A >
  {
    // auto_id
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        long unsigned int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    auto_id_type_;

    static const auto_id_type_ auto_id;

    // route
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    route_type_;

    static const route_type_ route;

    // mode
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    mode_type_;

    static const mode_type_ mode;

    // veh_type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    veh_type_type_;

    static const veh_type_type_ veh_type;

    // nodes
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    nodes_type_;

    static const nodes_type_ nodes;

    // name
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        ::std::string,
        sqlite::id_text >::query_type,
      sqlite::id_text >
    name_type_;

    static const name_type_ name;

    // node
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    node_type_;

    static const node_type_ node;

    // type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    type_type_;

    static const type_type_ type;

    // dwell
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    dwell_type_;

    static const dwell_type_ dwell;

    // time
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    time_type_;

    static const time_type_ time;

    // speed
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    speed_type_;

    static const speed_type_ speed;
  };

  template <typename A>
  const typename pointer_query_columns< ::pio::Route_Nodes, A >::auto_id_type_
  pointer_query_columns< ::pio::Route_Nodes, A >::
  auto_id (A::table_name, "\"auto_id\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Route_Nodes, A >::route_type_
  pointer_query_columns< ::pio::Route_Nodes, A >::
  route (A::table_name, "\"route\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Route_Nodes, A >::mode_type_
  pointer_query_columns< ::pio::Route_Nodes, A >::
  mode (A::table_name, "\"mode\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Route_Nodes, A >::veh_type_type_
  pointer_query_columns< ::pio::Route_Nodes, A >::
  veh_type (A::table_name, "\"veh_type\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Route_Nodes, A >::nodes_type_
  pointer_query_columns< ::pio::Route_Nodes, A >::
  nodes (A::table_name, "\"nodes\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Route_Nodes, A >::name_type_
  pointer_query_columns< ::pio::Route_Nodes, A >::
  name (A::table_name, "\"name\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Route_Nodes, A >::node_type_
  pointer_query_columns< ::pio::Route_Nodes, A >::
  node (A::table_name, "\"node\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Route_Nodes, A >::type_type_
  pointer_query_columns< ::pio::Route_Nodes, A >::
  type (A::table_name, "\"type\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Route_Nodes, A >::dwell_type_
  pointer_query_columns< ::pio::Route_Nodes, A >::
  dwell (A::table_name, "\"dwell\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Route_Nodes, A >::time_type_
  pointer_query_columns< ::pio::Route_Nodes, A >::
  time (A::table_name, "\"time\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Route_Nodes, A >::speed_type_
  pointer_query_columns< ::pio::Route_Nodes, A >::
  speed (A::table_name, "\"speed\"", 0);

  template <>
  class access::object_traits< ::pio::Route_Nodes >
  {
    public:
    typedef ::pio::Route_Nodes object_type;
    typedef ::std::tr1::shared_ptr< ::pio::Route_Nodes > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef long unsigned int id_type;
    static const bool auto_id = true;

    struct id_image_type
    {
      long long id_value;
      bool id_null;

      std::size_t version;
    };

    static const bool abstract = false;

    struct image_type
    {
      // auto_id
      //
      long long auto_id_value;
      bool auto_id_null;

      // route
      //
      long long route_value;
      bool route_null;

      // mode
      //
      long long mode_value;
      bool mode_null;

      // veh_type
      //
      long long veh_type_value;
      bool veh_type_null;

      // nodes
      //
      long long nodes_value;
      bool nodes_null;

      // name
      //
      details::buffer name_value;
      std::size_t name_size;
      bool name_null;

      // node
      //
      long long node_value;
      bool node_null;

      // type
      //
      long long type_value;
      bool type_null;

      // dwell
      //
      double dwell_value;
      bool dwell_null;

      // time
      //
      double time_value;
      bool time_null;

      // speed
      //
      double speed_value;
      bool speed_null;

      std::size_t version;
    };

    static id_type
    id (const object_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&, bool*);

    static void
    bind (sqlite::bind*,
          image_type&,
          sqlite::statement_kind);

    static void
    bind (sqlite::bind*, id_image_type&);

    static bool
    init (image_type&, const object_type&, sqlite::statement_kind);

    static void
    init (object_type&, const image_type&, database*);

    static void
    init (id_image_type&, const id_type&);

    typedef
    odb::pointer_cache_traits<pointer_type>
    pointer_cache_traits;
    typedef
    odb::reference_cache_traits<object_type>
    reference_cache_traits;

    typedef sqlite::object_statements<object_type> statements_type;

    typedef sqlite::query query_base_type;

    struct container_statement_cache_type;

    static const std::size_t column_count = 11UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static bool
    create_schema (database&, unsigned short pass, bool drop);

    public:
    static bool
    find_ (statements_type&, const id_type*);

    static void
    load_ (statements_type&, object_type&);
  };

  // Selection
  //
  template <>
  struct class_traits< ::pio::Selection >
  {
    static const class_kind kind = class_object;
  };

  template <typename A>
  struct query_columns< ::pio::Selection, A >
  {
    // auto_id
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        long unsigned int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    auto_id_type_;

    static const auto_id_type_ auto_id;

    // hhold
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    hhold_type_;

    static const hhold_type_ hhold;

    // person
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    person_type_;

    static const person_type_ person;

    // tour
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    tour_type_;

    static const tour_type_ tour;

    // trip
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    trip_type_;

    static const trip_type_ trip;

    // type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    type_type_;

    static const type_type_ type;

    // partition
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    partition_type_;

    static const partition_type_ partition;
  };

  template <typename A>
  const typename query_columns< ::pio::Selection, A >::auto_id_type_
  query_columns< ::pio::Selection, A >::
  auto_id (A::table_name, "\"auto_id\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Selection, A >::hhold_type_
  query_columns< ::pio::Selection, A >::
  hhold (A::table_name, "\"hhold\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Selection, A >::person_type_
  query_columns< ::pio::Selection, A >::
  person (A::table_name, "\"person\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Selection, A >::tour_type_
  query_columns< ::pio::Selection, A >::
  tour (A::table_name, "\"tour\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Selection, A >::trip_type_
  query_columns< ::pio::Selection, A >::
  trip (A::table_name, "\"trip\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Selection, A >::type_type_
  query_columns< ::pio::Selection, A >::
  type (A::table_name, "\"type\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Selection, A >::partition_type_
  query_columns< ::pio::Selection, A >::
  partition (A::table_name, "\"partition\"", 0);

  template <typename A>
  struct pointer_query_columns< ::pio::Selection, A >:
    query_columns< ::pio::Selection, A >
  {
  };

  template <>
  class access::object_traits< ::pio::Selection >
  {
    public:
    typedef ::pio::Selection object_type;
    typedef ::std::tr1::shared_ptr< ::pio::Selection > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef long unsigned int id_type;
    static const bool auto_id = true;

    struct id_image_type
    {
      long long id_value;
      bool id_null;

      std::size_t version;
    };

    static const bool abstract = false;

    struct image_type
    {
      // auto_id
      //
      long long auto_id_value;
      bool auto_id_null;

      // hhold
      //
      long long hhold_value;
      bool hhold_null;

      // person
      //
      long long person_value;
      bool person_null;

      // tour
      //
      long long tour_value;
      bool tour_null;

      // trip
      //
      long long trip_value;
      bool trip_null;

      // type
      //
      long long type_value;
      bool type_null;

      // partition
      //
      long long partition_value;
      bool partition_null;

      std::size_t version;
    };

    static id_type
    id (const object_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&, bool*);

    static void
    bind (sqlite::bind*,
          image_type&,
          sqlite::statement_kind);

    static void
    bind (sqlite::bind*, id_image_type&);

    static bool
    init (image_type&, const object_type&, sqlite::statement_kind);

    static void
    init (object_type&, const image_type&, database*);

    static void
    init (id_image_type&, const id_type&);

    typedef
    odb::pointer_cache_traits<pointer_type>
    pointer_cache_traits;
    typedef
    odb::reference_cache_traits<object_type>
    reference_cache_traits;

    typedef sqlite::object_statements<object_type> statements_type;

    typedef sqlite::query query_base_type;

    struct container_statement_cache_type;

    static const std::size_t column_count = 7UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static bool
    create_schema (database&, unsigned short pass, bool drop);

    public:
    static bool
    find_ (statements_type&, const id_type*);

    static void
    load_ (statements_type&, object_type&);
  };

  // Household
  //
  template <>
  struct class_traits< ::pio::Household >
  {
    static const class_kind kind = class_object;
  };

  template <typename A>
  struct pointer_query_columns< ::pio::Household, A >
  {
    // auto_id
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        long unsigned int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    auto_id_type_;

    static const auto_id_type_ auto_id;

    // hhold
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    hhold_type_;

    static const hhold_type_ hhold;

    // location
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    location_type_;

    static const location_type_ location;

    // persons
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    persons_type_;

    static const persons_type_ persons;

    // workers
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    workers_type_;

    static const workers_type_ workers;

    // vehicles
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    vehicles_type_;

    static const vehicles_type_ vehicles;

    // type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    type_type_;

    static const type_type_ type;

    // partition
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    partition_type_;

    static const partition_type_ partition;

    // person
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    person_type_;

    static const person_type_ person;

    // age
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    age_type_;

    static const age_type_ age;

    // relate
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    relate_type_;

    static const relate_type_ relate;

    // gender
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    gender_type_;

    static const gender_type_ gender;

    // work
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    work_type_;

    static const work_type_ work;

    // drive
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    drive_type_;

    static const drive_type_ drive;
  };

  template <typename A>
  const typename pointer_query_columns< ::pio::Household, A >::auto_id_type_
  pointer_query_columns< ::pio::Household, A >::
  auto_id (A::table_name, "\"auto_id\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Household, A >::hhold_type_
  pointer_query_columns< ::pio::Household, A >::
  hhold (A::table_name, "\"hhold\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Household, A >::location_type_
  pointer_query_columns< ::pio::Household, A >::
  location (A::table_name, "\"location\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Household, A >::persons_type_
  pointer_query_columns< ::pio::Household, A >::
  persons (A::table_name, "\"persons\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Household, A >::workers_type_
  pointer_query_columns< ::pio::Household, A >::
  workers (A::table_name, "\"workers\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Household, A >::vehicles_type_
  pointer_query_columns< ::pio::Household, A >::
  vehicles (A::table_name, "\"vehicles\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Household, A >::type_type_
  pointer_query_columns< ::pio::Household, A >::
  type (A::table_name, "\"type\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Household, A >::partition_type_
  pointer_query_columns< ::pio::Household, A >::
  partition (A::table_name, "\"partition\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Household, A >::person_type_
  pointer_query_columns< ::pio::Household, A >::
  person (A::table_name, "\"person\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Household, A >::age_type_
  pointer_query_columns< ::pio::Household, A >::
  age (A::table_name, "\"age\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Household, A >::relate_type_
  pointer_query_columns< ::pio::Household, A >::
  relate (A::table_name, "\"relate\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Household, A >::gender_type_
  pointer_query_columns< ::pio::Household, A >::
  gender (A::table_name, "\"gender\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Household, A >::work_type_
  pointer_query_columns< ::pio::Household, A >::
  work (A::table_name, "\"work\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Household, A >::drive_type_
  pointer_query_columns< ::pio::Household, A >::
  drive (A::table_name, "\"drive\"", 0);

  template <>
  class access::object_traits< ::pio::Household >
  {
    public:
    typedef ::pio::Household object_type;
    typedef ::std::tr1::shared_ptr< ::pio::Household > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef long unsigned int id_type;
    static const bool auto_id = true;

    struct id_image_type
    {
      long long id_value;
      bool id_null;

      std::size_t version;
    };

    static const bool abstract = false;

    struct image_type
    {
      // auto_id
      //
      long long auto_id_value;
      bool auto_id_null;

      // hhold
      //
      long long hhold_value;
      bool hhold_null;

      // location
      //
      long long location_value;
      bool location_null;

      // persons
      //
      long long persons_value;
      bool persons_null;

      // workers
      //
      long long workers_value;
      bool workers_null;

      // vehicles
      //
      long long vehicles_value;
      bool vehicles_null;

      // type
      //
      long long type_value;
      bool type_null;

      // partition
      //
      long long partition_value;
      bool partition_null;

      // person
      //
      long long person_value;
      bool person_null;

      // age
      //
      long long age_value;
      bool age_null;

      // relate
      //
      long long relate_value;
      bool relate_null;

      // gender
      //
      long long gender_value;
      bool gender_null;

      // work
      //
      long long work_value;
      bool work_null;

      // drive
      //
      long long drive_value;
      bool drive_null;

      std::size_t version;
    };

    static id_type
    id (const object_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&, bool*);

    static void
    bind (sqlite::bind*,
          image_type&,
          sqlite::statement_kind);

    static void
    bind (sqlite::bind*, id_image_type&);

    static bool
    init (image_type&, const object_type&, sqlite::statement_kind);

    static void
    init (object_type&, const image_type&, database*);

    static void
    init (id_image_type&, const id_type&);

    typedef
    odb::pointer_cache_traits<pointer_type>
    pointer_cache_traits;
    typedef
    odb::reference_cache_traits<object_type>
    reference_cache_traits;

    typedef sqlite::object_statements<object_type> statements_type;

    typedef sqlite::query query_base_type;

    struct container_statement_cache_type;

    static const std::size_t column_count = 14UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static bool
    create_schema (database&, unsigned short pass, bool drop);

    public:
    static bool
    find_ (statements_type&, const id_type*);

    static void
    load_ (statements_type&, object_type&);
  };

  // Link_Delay
  //
  template <>
  struct class_traits< ::pio::Link_Delay >
  {
    static const class_kind kind = class_object;
  };

  template <typename A>
  struct pointer_query_columns< ::pio::Link_Delay, A >
  {
    // auto_id
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        long unsigned int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    auto_id_type_;

    static const auto_id_type_ auto_id;

    // link
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    link_type_;

    static const link_type_ link;

    // dir
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    dir_type_;

    static const dir_type_ dir;

    // type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    type_type_;

    static const type_type_ type;

    // start
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    start_type_;

    static const start_type_ start;

    // end
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    end_type_;

    static const end_type_ end;

    // flow
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    flow_type_;

    static const flow_type_ flow;

    // time
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    time_type_;

    static const time_type_ time;

    // out_link
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    out_link_type_;

    static const out_link_type_ out_link;

    // out_flow
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    out_flow_type_;

    static const out_flow_type_ out_flow;

    // out_time
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    out_time_type_;

    static const out_time_type_ out_time;
  };

  template <typename A>
  const typename pointer_query_columns< ::pio::Link_Delay, A >::auto_id_type_
  pointer_query_columns< ::pio::Link_Delay, A >::
  auto_id (A::table_name, "\"auto_id\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Link_Delay, A >::link_type_
  pointer_query_columns< ::pio::Link_Delay, A >::
  link (A::table_name, "\"link\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Link_Delay, A >::dir_type_
  pointer_query_columns< ::pio::Link_Delay, A >::
  dir (A::table_name, "\"dir\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Link_Delay, A >::type_type_
  pointer_query_columns< ::pio::Link_Delay, A >::
  type (A::table_name, "\"type\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Link_Delay, A >::start_type_
  pointer_query_columns< ::pio::Link_Delay, A >::
  start (A::table_name, "\"start\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Link_Delay, A >::end_type_
  pointer_query_columns< ::pio::Link_Delay, A >::
  end (A::table_name, "\"end\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Link_Delay, A >::flow_type_
  pointer_query_columns< ::pio::Link_Delay, A >::
  flow (A::table_name, "\"flow\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Link_Delay, A >::time_type_
  pointer_query_columns< ::pio::Link_Delay, A >::
  time (A::table_name, "\"time\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Link_Delay, A >::out_link_type_
  pointer_query_columns< ::pio::Link_Delay, A >::
  out_link (A::table_name, "\"out_link\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Link_Delay, A >::out_flow_type_
  pointer_query_columns< ::pio::Link_Delay, A >::
  out_flow (A::table_name, "\"out_flow\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Link_Delay, A >::out_time_type_
  pointer_query_columns< ::pio::Link_Delay, A >::
  out_time (A::table_name, "\"out_time\"", 0);

  template <>
  class access::object_traits< ::pio::Link_Delay >
  {
    public:
    typedef ::pio::Link_Delay object_type;
    typedef ::std::tr1::shared_ptr< ::pio::Link_Delay > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef long unsigned int id_type;
    static const bool auto_id = true;

    struct id_image_type
    {
      long long id_value;
      bool id_null;

      std::size_t version;
    };

    static const bool abstract = false;

    struct image_type
    {
      // auto_id
      //
      long long auto_id_value;
      bool auto_id_null;

      // link
      //
      long long link_value;
      bool link_null;

      // dir
      //
      long long dir_value;
      bool dir_null;

      // type
      //
      long long type_value;
      bool type_null;

      // start
      //
      double start_value;
      bool start_null;

      // end
      //
      double end_value;
      bool end_null;

      // flow
      //
      double flow_value;
      bool flow_null;

      // time
      //
      double time_value;
      bool time_null;

      // out_link
      //
      long long out_link_value;
      bool out_link_null;

      // out_flow
      //
      double out_flow_value;
      bool out_flow_null;

      // out_time
      //
      double out_time_value;
      bool out_time_null;

      std::size_t version;
    };

    static id_type
    id (const object_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&, bool*);

    static void
    bind (sqlite::bind*,
          image_type&,
          sqlite::statement_kind);

    static void
    bind (sqlite::bind*, id_image_type&);

    static bool
    init (image_type&, const object_type&, sqlite::statement_kind);

    static void
    init (object_type&, const image_type&, database*);

    static void
    init (id_image_type&, const id_type&);

    typedef
    odb::pointer_cache_traits<pointer_type>
    pointer_cache_traits;
    typedef
    odb::reference_cache_traits<object_type>
    reference_cache_traits;

    typedef sqlite::object_statements<object_type> statements_type;

    typedef sqlite::query query_base_type;

    struct container_statement_cache_type;

    static const std::size_t column_count = 11UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static bool
    create_schema (database&, unsigned short pass, bool drop);

    public:
    static bool
    find_ (statements_type&, const id_type*);

    static void
    load_ (statements_type&, object_type&);
  };

  // Performance
  //
  template <>
  struct class_traits< ::pio::Performance >
  {
    static const class_kind kind = class_object;
  };

  template <typename A>
  struct query_columns< ::pio::Performance, A >
  {
    // auto_id
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        long unsigned int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    auto_id_type_;

    static const auto_id_type_ auto_id;

    // speed
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    speed_type_;

    static const speed_type_ speed;

    // delay
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    delay_type_;

    static const delay_type_ delay;

    // density
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    density_type_;

    static const density_type_ density;

    // max_den
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    max_den_type_;

    static const max_den_type_ max_den;

    // ratio
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    ratio_type_;

    static const ratio_type_ ratio;

    // queue
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    queue_type_;

    static const queue_type_ queue;

    // max_que
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    max_que_type_;

    static const max_que_type_ max_que;

    // fail
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    fail_type_;

    static const fail_type_ fail;
  };

  template <typename A>
  const typename query_columns< ::pio::Performance, A >::auto_id_type_
  query_columns< ::pio::Performance, A >::
  auto_id (A::table_name, "\"auto_id\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Performance, A >::speed_type_
  query_columns< ::pio::Performance, A >::
  speed (A::table_name, "\"speed\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Performance, A >::delay_type_
  query_columns< ::pio::Performance, A >::
  delay (A::table_name, "\"delay\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Performance, A >::density_type_
  query_columns< ::pio::Performance, A >::
  density (A::table_name, "\"density\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Performance, A >::max_den_type_
  query_columns< ::pio::Performance, A >::
  max_den (A::table_name, "\"max_den\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Performance, A >::ratio_type_
  query_columns< ::pio::Performance, A >::
  ratio (A::table_name, "\"ratio\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Performance, A >::queue_type_
  query_columns< ::pio::Performance, A >::
  queue (A::table_name, "\"queue\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Performance, A >::max_que_type_
  query_columns< ::pio::Performance, A >::
  max_que (A::table_name, "\"max_que\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Performance, A >::fail_type_
  query_columns< ::pio::Performance, A >::
  fail (A::table_name, "\"fail\"", 0);

  template <typename A>
  struct pointer_query_columns< ::pio::Performance, A >:
    query_columns< ::pio::Performance, A >
  {
  };

  template <>
  class access::object_traits< ::pio::Performance >
  {
    public:
    typedef ::pio::Performance object_type;
    typedef ::std::tr1::shared_ptr< ::pio::Performance > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef long unsigned int id_type;
    static const bool auto_id = true;

    struct id_image_type
    {
      long long id_value;
      bool id_null;

      std::size_t version;
    };

    static const bool abstract = false;

    struct image_type
    {
      // auto_id
      //
      long long auto_id_value;
      bool auto_id_null;

      // speed
      //
      double speed_value;
      bool speed_null;

      // delay
      //
      double delay_value;
      bool delay_null;

      // density
      //
      double density_value;
      bool density_null;

      // max_den
      //
      double max_den_value;
      bool max_den_null;

      // ratio
      //
      double ratio_value;
      bool ratio_null;

      // queue
      //
      double queue_value;
      bool queue_null;

      // max_que
      //
      long long max_que_value;
      bool max_que_null;

      // fail
      //
      long long fail_value;
      bool fail_null;

      std::size_t version;
    };

    static id_type
    id (const object_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&, bool*);

    static void
    bind (sqlite::bind*,
          image_type&,
          sqlite::statement_kind);

    static void
    bind (sqlite::bind*, id_image_type&);

    static bool
    init (image_type&, const object_type&, sqlite::statement_kind);

    static void
    init (object_type&, const image_type&, database*);

    static void
    init (id_image_type&, const id_type&);

    typedef
    odb::pointer_cache_traits<pointer_type>
    pointer_cache_traits;
    typedef
    odb::reference_cache_traits<object_type>
    reference_cache_traits;

    typedef sqlite::object_statements<object_type> statements_type;

    typedef sqlite::query query_base_type;

    struct container_statement_cache_type;

    static const std::size_t column_count = 9UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static bool
    create_schema (database&, unsigned short pass, bool drop);

    public:
    static bool
    find_ (statements_type&, const id_type*);

    static void
    load_ (statements_type&, object_type&);
  };

  // Ridership
  //
  template <>
  struct class_traits< ::pio::Ridership >
  {
    static const class_kind kind = class_object;
  };

  template <typename A>
  struct pointer_query_columns< ::pio::Ridership, A >
  {
    // auto_id
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        long unsigned int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    auto_id_type_;

    static const auto_id_type_ auto_id;

    // mode
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    mode_type_;

    static const mode_type_ mode;

    // route
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    route_type_;

    static const route_type_ route;

    // run
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    run_type_;

    static const run_type_ run;

    // stop
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    stop_type_;

    static const stop_type_ stop;

    // schedule
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    schedule_type_;

    static const schedule_type_ schedule;

    // time
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    time_type_;

    static const time_type_ time;

    // board
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    board_type_;

    static const board_type_ board;

    // alight
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    alight_type_;

    static const alight_type_ alight;

    // load
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    load_type_;

    static const load_type_ load;

    // factor
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    factor_type_;

    static const factor_type_ factor;
  };

  template <typename A>
  const typename pointer_query_columns< ::pio::Ridership, A >::auto_id_type_
  pointer_query_columns< ::pio::Ridership, A >::
  auto_id (A::table_name, "\"auto_id\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Ridership, A >::mode_type_
  pointer_query_columns< ::pio::Ridership, A >::
  mode (A::table_name, "\"mode\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Ridership, A >::route_type_
  pointer_query_columns< ::pio::Ridership, A >::
  route (A::table_name, "\"route\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Ridership, A >::run_type_
  pointer_query_columns< ::pio::Ridership, A >::
  run (A::table_name, "\"run\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Ridership, A >::stop_type_
  pointer_query_columns< ::pio::Ridership, A >::
  stop (A::table_name, "\"stop\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Ridership, A >::schedule_type_
  pointer_query_columns< ::pio::Ridership, A >::
  schedule (A::table_name, "\"schedule\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Ridership, A >::time_type_
  pointer_query_columns< ::pio::Ridership, A >::
  time (A::table_name, "\"time\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Ridership, A >::board_type_
  pointer_query_columns< ::pio::Ridership, A >::
  board (A::table_name, "\"board\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Ridership, A >::alight_type_
  pointer_query_columns< ::pio::Ridership, A >::
  alight (A::table_name, "\"alight\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Ridership, A >::load_type_
  pointer_query_columns< ::pio::Ridership, A >::
  load (A::table_name, "\"load\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Ridership, A >::factor_type_
  pointer_query_columns< ::pio::Ridership, A >::
  factor (A::table_name, "\"factor\"", 0);

  template <>
  class access::object_traits< ::pio::Ridership >
  {
    public:
    typedef ::pio::Ridership object_type;
    typedef ::std::tr1::shared_ptr< ::pio::Ridership > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef long unsigned int id_type;
    static const bool auto_id = true;

    struct id_image_type
    {
      long long id_value;
      bool id_null;

      std::size_t version;
    };

    static const bool abstract = false;

    struct image_type
    {
      // auto_id
      //
      long long auto_id_value;
      bool auto_id_null;

      // mode
      //
      long long mode_value;
      bool mode_null;

      // route
      //
      long long route_value;
      bool route_null;

      // run
      //
      long long run_value;
      bool run_null;

      // stop
      //
      long long stop_value;
      bool stop_null;

      // schedule
      //
      double schedule_value;
      bool schedule_null;

      // time
      //
      double time_value;
      bool time_null;

      // board
      //
      long long board_value;
      bool board_null;

      // alight
      //
      long long alight_value;
      bool alight_null;

      // load
      //
      long long load_value;
      bool load_null;

      // factor
      //
      double factor_value;
      bool factor_null;

      std::size_t version;
    };

    static id_type
    id (const object_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&, bool*);

    static void
    bind (sqlite::bind*,
          image_type&,
          sqlite::statement_kind);

    static void
    bind (sqlite::bind*, id_image_type&);

    static bool
    init (image_type&, const object_type&, sqlite::statement_kind);

    static void
    init (object_type&, const image_type&, database*);

    static void
    init (id_image_type&, const id_type&);

    typedef
    odb::pointer_cache_traits<pointer_type>
    pointer_cache_traits;
    typedef
    odb::reference_cache_traits<object_type>
    reference_cache_traits;

    typedef sqlite::object_statements<object_type> statements_type;

    typedef sqlite::query query_base_type;

    struct container_statement_cache_type;

    static const std::size_t column_count = 11UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static bool
    create_schema (database&, unsigned short pass, bool drop);

    public:
    static bool
    find_ (statements_type&, const id_type*);

    static void
    load_ (statements_type&, object_type&);
  };

  // Veh_Type
  //
  template <>
  struct class_traits< ::pio::Veh_Type >
  {
    static const class_kind kind = class_object;
  };

  template <typename A>
  struct query_columns< ::pio::Veh_Type, A >
  {
    // type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    type_type_;

    static const type_type_ type;

    // length
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    length_type_;

    static const length_type_ length;

    // max_speed
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    max_speed_type_;

    static const max_speed_type_ max_speed;

    // max_accel
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    max_accel_type_;

    static const max_accel_type_ max_accel;

    // max_decel
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    max_decel_type_;

    static const max_decel_type_ max_decel;

    // op_cost
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    op_cost_type_;

    static const op_cost_type_ op_cost;

    // use
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    use_type_;

    static const use_type_ use;

    // capacity
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    capacity_type_;

    static const capacity_type_ capacity;

    // load
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    load_type_;

    static const load_type_ load;

    // unload
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    unload_type_;

    static const unload_type_ unload;

    // method
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    method_type_;

    static const method_type_ method;

    // min_dwell
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    min_dwell_type_;

    static const min_dwell_type_ min_dwell;

    // max_dwell
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    max_dwell_type_;

    static const max_dwell_type_ max_dwell;

    // subtype
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    subtype_type_;

    static const subtype_type_ subtype;
  };

  template <typename A>
  const typename query_columns< ::pio::Veh_Type, A >::type_type_
  query_columns< ::pio::Veh_Type, A >::
  type (A::table_name, "\"type\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Veh_Type, A >::length_type_
  query_columns< ::pio::Veh_Type, A >::
  length (A::table_name, "\"length\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Veh_Type, A >::max_speed_type_
  query_columns< ::pio::Veh_Type, A >::
  max_speed (A::table_name, "\"max_speed\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Veh_Type, A >::max_accel_type_
  query_columns< ::pio::Veh_Type, A >::
  max_accel (A::table_name, "\"max_accel\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Veh_Type, A >::max_decel_type_
  query_columns< ::pio::Veh_Type, A >::
  max_decel (A::table_name, "\"max_decel\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Veh_Type, A >::op_cost_type_
  query_columns< ::pio::Veh_Type, A >::
  op_cost (A::table_name, "\"op_cost\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Veh_Type, A >::use_type_
  query_columns< ::pio::Veh_Type, A >::
  use (A::table_name, "\"use\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Veh_Type, A >::capacity_type_
  query_columns< ::pio::Veh_Type, A >::
  capacity (A::table_name, "\"capacity\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Veh_Type, A >::load_type_
  query_columns< ::pio::Veh_Type, A >::
  load (A::table_name, "\"load\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Veh_Type, A >::unload_type_
  query_columns< ::pio::Veh_Type, A >::
  unload (A::table_name, "\"unload\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Veh_Type, A >::method_type_
  query_columns< ::pio::Veh_Type, A >::
  method (A::table_name, "\"method\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Veh_Type, A >::min_dwell_type_
  query_columns< ::pio::Veh_Type, A >::
  min_dwell (A::table_name, "\"min_dwell\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Veh_Type, A >::max_dwell_type_
  query_columns< ::pio::Veh_Type, A >::
  max_dwell (A::table_name, "\"max_dwell\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Veh_Type, A >::subtype_type_
  query_columns< ::pio::Veh_Type, A >::
  subtype (A::table_name, "\"subtype\"", 0);

  template <typename A>
  struct pointer_query_columns< ::pio::Veh_Type, A >:
    query_columns< ::pio::Veh_Type, A >
  {
  };

  template <>
  class access::object_traits< ::pio::Veh_Type >
  {
    public:
    typedef ::pio::Veh_Type object_type;
    typedef ::std::tr1::shared_ptr< ::pio::Veh_Type > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef int id_type;
    static const bool auto_id = false;

    struct id_image_type
    {
      long long id_value;
      bool id_null;

      std::size_t version;
    };

    static const bool abstract = false;

    struct image_type
    {
      // type
      //
      long long type_value;
      bool type_null;

      // length
      //
      double length_value;
      bool length_null;

      // max_speed
      //
      double max_speed_value;
      bool max_speed_null;

      // max_accel
      //
      double max_accel_value;
      bool max_accel_null;

      // max_decel
      //
      double max_decel_value;
      bool max_decel_null;

      // op_cost
      //
      double op_cost_value;
      bool op_cost_null;

      // use
      //
      long long use_value;
      bool use_null;

      // capacity
      //
      long long capacity_value;
      bool capacity_null;

      // load
      //
      double load_value;
      bool load_null;

      // unload
      //
      double unload_value;
      bool unload_null;

      // method
      //
      long long method_value;
      bool method_null;

      // min_dwell
      //
      double min_dwell_value;
      bool min_dwell_null;

      // max_dwell
      //
      double max_dwell_value;
      bool max_dwell_null;

      // subtype
      //
      long long subtype_value;
      bool subtype_null;

      std::size_t version;
    };

    static id_type
    id (const object_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&, bool*);

    static void
    bind (sqlite::bind*,
          image_type&,
          sqlite::statement_kind);

    static void
    bind (sqlite::bind*, id_image_type&);

    static bool
    init (image_type&, const object_type&, sqlite::statement_kind);

    static void
    init (object_type&, const image_type&, database*);

    static void
    init (id_image_type&, const id_type&);

    typedef
    odb::pointer_cache_traits<pointer_type>
    pointer_cache_traits;
    typedef
    odb::reference_cache_traits<object_type>
    reference_cache_traits;

    typedef sqlite::object_statements<object_type> statements_type;

    typedef sqlite::query query_base_type;

    struct container_statement_cache_type;

    static const std::size_t column_count = 14UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);

    static void
    persist (database&, const object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static bool
    create_schema (database&, unsigned short pass, bool drop);

    public:
    static bool
    find_ (statements_type&, const id_type*);

    static void
    load_ (statements_type&, object_type&);
  };

  // Vehicle
  //
  template <>
  struct class_traits< ::pio::Vehicle >
  {
    static const class_kind kind = class_object;
  };

  template <typename A>
  struct pointer_query_columns< ::pio::Vehicle, A >
  {
    // auto_id
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        long unsigned int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    auto_id_type_;

    static const auto_id_type_ auto_id;

    // hhold
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    hhold_type_;

    static const hhold_type_ hhold;

    // vehicle
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    vehicle_type_;

    static const vehicle_type_ vehicle;

    // parking
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    parking_type_;

    static const parking_type_ parking;

    // type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    type_type_;

    static const type_type_ type;

    // subtype
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    subtype_type_;

    static const subtype_type_ subtype;

    // partition
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    partition_type_;

    static const partition_type_ partition;
  };

  template <typename A>
  const typename pointer_query_columns< ::pio::Vehicle, A >::auto_id_type_
  pointer_query_columns< ::pio::Vehicle, A >::
  auto_id (A::table_name, "\"auto_id\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Vehicle, A >::hhold_type_
  pointer_query_columns< ::pio::Vehicle, A >::
  hhold (A::table_name, "\"hhold\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Vehicle, A >::vehicle_type_
  pointer_query_columns< ::pio::Vehicle, A >::
  vehicle (A::table_name, "\"vehicle\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Vehicle, A >::parking_type_
  pointer_query_columns< ::pio::Vehicle, A >::
  parking (A::table_name, "\"parking\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Vehicle, A >::type_type_
  pointer_query_columns< ::pio::Vehicle, A >::
  type (A::table_name, "\"type\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Vehicle, A >::subtype_type_
  pointer_query_columns< ::pio::Vehicle, A >::
  subtype (A::table_name, "\"subtype\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Vehicle, A >::partition_type_
  pointer_query_columns< ::pio::Vehicle, A >::
  partition (A::table_name, "\"partition\"", 0);

  template <>
  class access::object_traits< ::pio::Vehicle >
  {
    public:
    typedef ::pio::Vehicle object_type;
    typedef ::std::tr1::shared_ptr< ::pio::Vehicle > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef long unsigned int id_type;
    static const bool auto_id = true;

    struct id_image_type
    {
      long long id_value;
      bool id_null;

      std::size_t version;
    };

    static const bool abstract = false;

    struct image_type
    {
      // auto_id
      //
      long long auto_id_value;
      bool auto_id_null;

      // hhold
      //
      long long hhold_value;
      bool hhold_null;

      // vehicle
      //
      long long vehicle_value;
      bool vehicle_null;

      // parking
      //
      long long parking_value;
      bool parking_null;

      // type
      //
      long long type_value;
      bool type_null;

      // subtype
      //
      long long subtype_value;
      bool subtype_null;

      // partition
      //
      long long partition_value;
      bool partition_null;

      std::size_t version;
    };

    static id_type
    id (const object_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&, bool*);

    static void
    bind (sqlite::bind*,
          image_type&,
          sqlite::statement_kind);

    static void
    bind (sqlite::bind*, id_image_type&);

    static bool
    init (image_type&, const object_type&, sqlite::statement_kind);

    static void
    init (object_type&, const image_type&, database*);

    static void
    init (id_image_type&, const id_type&);

    typedef
    odb::pointer_cache_traits<pointer_type>
    pointer_cache_traits;
    typedef
    odb::reference_cache_traits<object_type>
    reference_cache_traits;

    typedef sqlite::object_statements<object_type> statements_type;

    typedef sqlite::query query_base_type;

    struct container_statement_cache_type;

    static const std::size_t column_count = 7UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static bool
    create_schema (database&, unsigned short pass, bool drop);

    public:
    static bool
    find_ (statements_type&, const id_type*);

    static void
    load_ (statements_type&, object_type&);
  };

  // Trip
  //
  template <>
  struct class_traits< ::pio::Trip >
  {
    static const class_kind kind = class_object;
  };

  template <typename A>
  struct pointer_query_columns< ::pio::Trip, A >
  {
    // auto_id
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        long unsigned int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    auto_id_type_;

    static const auto_id_type_ auto_id;

    // hhold
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    hhold_type_;

    static const hhold_type_ hhold;

    // person
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    person_type_;

    static const person_type_ person;

    // tour
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    tour_type_;

    static const tour_type_ tour;

    // trip
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    trip_type_;

    static const trip_type_ trip;

    // start
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    start_type_;

    static const start_type_ start;

    // end
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    end_type_;

    static const end_type_ end;

    // duration
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    duration_type_;

    static const duration_type_ duration;

    // origin
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    origin_type_;

    static const origin_type_ origin;

    // destination
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    destination_type_;

    static const destination_type_ destination;

    // purpose
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    purpose_type_;

    static const purpose_type_ purpose;

    // mode
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    mode_type_;

    static const mode_type_ mode;

    // constraint
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    constraint_type_;

    static const constraint_type_ constraint;

    // priority
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    priority_type_;

    static const priority_type_ priority;

    // vehicle
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    vehicle_type_;

    static const vehicle_type_ vehicle;

    // passengers
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    passengers_type_;

    static const passengers_type_ passengers;

    // type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    type_type_;

    static const type_type_ type;

    // partition
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    partition_type_;

    static const partition_type_ partition;
  };

  template <typename A>
  const typename pointer_query_columns< ::pio::Trip, A >::auto_id_type_
  pointer_query_columns< ::pio::Trip, A >::
  auto_id (A::table_name, "\"auto_id\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Trip, A >::hhold_type_
  pointer_query_columns< ::pio::Trip, A >::
  hhold (A::table_name, "\"hhold\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Trip, A >::person_type_
  pointer_query_columns< ::pio::Trip, A >::
  person (A::table_name, "\"person\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Trip, A >::tour_type_
  pointer_query_columns< ::pio::Trip, A >::
  tour (A::table_name, "\"tour\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Trip, A >::trip_type_
  pointer_query_columns< ::pio::Trip, A >::
  trip (A::table_name, "\"trip\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Trip, A >::start_type_
  pointer_query_columns< ::pio::Trip, A >::
  start (A::table_name, "\"start\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Trip, A >::end_type_
  pointer_query_columns< ::pio::Trip, A >::
  end (A::table_name, "\"end\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Trip, A >::duration_type_
  pointer_query_columns< ::pio::Trip, A >::
  duration (A::table_name, "\"duration\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Trip, A >::origin_type_
  pointer_query_columns< ::pio::Trip, A >::
  origin (A::table_name, "\"origin\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Trip, A >::destination_type_
  pointer_query_columns< ::pio::Trip, A >::
  destination (A::table_name, "\"destination\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Trip, A >::purpose_type_
  pointer_query_columns< ::pio::Trip, A >::
  purpose (A::table_name, "\"purpose\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Trip, A >::mode_type_
  pointer_query_columns< ::pio::Trip, A >::
  mode (A::table_name, "\"mode\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Trip, A >::constraint_type_
  pointer_query_columns< ::pio::Trip, A >::
  constraint (A::table_name, "\"constraint\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Trip, A >::priority_type_
  pointer_query_columns< ::pio::Trip, A >::
  priority (A::table_name, "\"priority\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Trip, A >::vehicle_type_
  pointer_query_columns< ::pio::Trip, A >::
  vehicle (A::table_name, "\"vehicle\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Trip, A >::passengers_type_
  pointer_query_columns< ::pio::Trip, A >::
  passengers (A::table_name, "\"passengers\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Trip, A >::type_type_
  pointer_query_columns< ::pio::Trip, A >::
  type (A::table_name, "\"type\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Trip, A >::partition_type_
  pointer_query_columns< ::pio::Trip, A >::
  partition (A::table_name, "\"partition\"", 0);

  template <>
  class access::object_traits< ::pio::Trip >
  {
    public:
    typedef ::pio::Trip object_type;
    typedef ::std::tr1::shared_ptr< ::pio::Trip > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef long unsigned int id_type;
    static const bool auto_id = true;

    struct id_image_type
    {
      long long id_value;
      bool id_null;

      std::size_t version;
    };

    static const bool abstract = false;

    struct image_type
    {
      // auto_id
      //
      long long auto_id_value;
      bool auto_id_null;

      // hhold
      //
      long long hhold_value;
      bool hhold_null;

      // person
      //
      long long person_value;
      bool person_null;

      // tour
      //
      long long tour_value;
      bool tour_null;

      // trip
      //
      long long trip_value;
      bool trip_null;

      // start
      //
      double start_value;
      bool start_null;

      // end
      //
      double end_value;
      bool end_null;

      // duration
      //
      double duration_value;
      bool duration_null;

      // origin
      //
      long long origin_value;
      bool origin_null;

      // destination
      //
      long long destination_value;
      bool destination_null;

      // purpose
      //
      long long purpose_value;
      bool purpose_null;

      // mode
      //
      long long mode_value;
      bool mode_null;

      // constraint
      //
      long long constraint_value;
      bool constraint_null;

      // priority
      //
      long long priority_value;
      bool priority_null;

      // vehicle
      //
      long long vehicle_value;
      bool vehicle_null;

      // passengers
      //
      long long passengers_value;
      bool passengers_null;

      // type
      //
      long long type_value;
      bool type_null;

      // partition
      //
      long long partition_value;
      bool partition_null;

      std::size_t version;
    };

    static id_type
    id (const object_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&, bool*);

    static void
    bind (sqlite::bind*,
          image_type&,
          sqlite::statement_kind);

    static void
    bind (sqlite::bind*, id_image_type&);

    static bool
    init (image_type&, const object_type&, sqlite::statement_kind);

    static void
    init (object_type&, const image_type&, database*);

    static void
    init (id_image_type&, const id_type&);

    typedef
    odb::pointer_cache_traits<pointer_type>
    pointer_cache_traits;
    typedef
    odb::reference_cache_traits<object_type>
    reference_cache_traits;

    typedef sqlite::object_statements<object_type> statements_type;

    typedef sqlite::query query_base_type;

    struct container_statement_cache_type;

    static const std::size_t column_count = 18UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static bool
    create_schema (database&, unsigned short pass, bool drop);

    public:
    static bool
    find_ (statements_type&, const id_type*);

    static void
    load_ (statements_type&, object_type&);
  };

  // Problem
  //
  template <>
  struct class_traits< ::pio::Problem >
  {
    static const class_kind kind = class_object;
  };

  template <typename A>
  struct pointer_query_columns< ::pio::Problem, A >
  {
    // problem
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    problem_type_;

    static const problem_type_ problem;

    // time
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    time_type_;

    static const time_type_ time;

    // link
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    link_type_;

    static const link_type_ link;

    // dir
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    dir_type_;

    static const dir_type_ dir;

    // lane
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    lane_type_;

    static const lane_type_ lane;

    // offset
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    offset_type_;

    static const offset_type_ offset;

    // route
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    route_type_;

    static const route_type_ route;

    // survey
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    survey_type_;

    static const survey_type_ survey;
  };

  template <typename A>
  const typename pointer_query_columns< ::pio::Problem, A >::problem_type_
  pointer_query_columns< ::pio::Problem, A >::
  problem (A::table_name, "\"problem\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Problem, A >::time_type_
  pointer_query_columns< ::pio::Problem, A >::
  time (A::table_name, "\"time\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Problem, A >::link_type_
  pointer_query_columns< ::pio::Problem, A >::
  link (A::table_name, "\"link\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Problem, A >::dir_type_
  pointer_query_columns< ::pio::Problem, A >::
  dir (A::table_name, "\"dir\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Problem, A >::lane_type_
  pointer_query_columns< ::pio::Problem, A >::
  lane (A::table_name, "\"lane\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Problem, A >::offset_type_
  pointer_query_columns< ::pio::Problem, A >::
  offset (A::table_name, "\"offset\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Problem, A >::route_type_
  pointer_query_columns< ::pio::Problem, A >::
  route (A::table_name, "\"route\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Problem, A >::survey_type_
  pointer_query_columns< ::pio::Problem, A >::
  survey (A::table_name, "\"survey\"", 0);

  template <>
  class access::object_traits< ::pio::Problem >
  {
    public:
    typedef ::pio::Problem object_type;
    typedef ::std::tr1::shared_ptr< ::pio::Problem > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef int id_type;
    static const bool auto_id = false;

    struct id_image_type
    {
      long long id_value;
      bool id_null;

      std::size_t version;
    };

    static const bool abstract = false;

    struct image_type
    {
      // problem
      //
      long long problem_value;
      bool problem_null;

      // time
      //
      double time_value;
      bool time_null;

      // link
      //
      long long link_value;
      bool link_null;

      // dir
      //
      long long dir_value;
      bool dir_null;

      // lane
      //
      long long lane_value;
      bool lane_null;

      // offset
      //
      double offset_value;
      bool offset_null;

      // route
      //
      long long route_value;
      bool route_null;

      // survey
      //
      long long survey_value;
      bool survey_null;

      std::size_t version;
    };

    static id_type
    id (const object_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&, bool*);

    static void
    bind (sqlite::bind*,
          image_type&,
          sqlite::statement_kind);

    static void
    bind (sqlite::bind*, id_image_type&);

    static bool
    init (image_type&, const object_type&, sqlite::statement_kind);

    static void
    init (object_type&, const image_type&, database*);

    static void
    init (id_image_type&, const id_type&);

    typedef
    odb::pointer_cache_traits<pointer_type>
    pointer_cache_traits;
    typedef
    odb::reference_cache_traits<object_type>
    reference_cache_traits;

    typedef sqlite::object_statements<object_type> statements_type;

    typedef sqlite::query query_base_type;

    struct container_statement_cache_type;

    static const std::size_t column_count = 8UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);

    static void
    persist (database&, const object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static bool
    create_schema (database&, unsigned short pass, bool drop);

    public:
    static bool
    find_ (statements_type&, const id_type*);

    static void
    load_ (statements_type&, object_type&);
  };

  // Plan
  //
  template <>
  struct class_traits< ::pio::Plan >
  {
    static const class_kind kind = class_object;
  };

  template <typename A>
  struct query_columns< ::pio::Plan, A >
  {
    // auto_id
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        long unsigned int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    auto_id_type_;

    static const auto_id_type_ auto_id;

    // depart
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    depart_type_;

    static const depart_type_ depart;

    // arrive
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    arrive_type_;

    static const arrive_type_ arrive;

    // activity
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    activity_type_;

    static const activity_type_ activity;

    // walk
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    walk_type_;

    static const walk_type_ walk;

    // drive
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    drive_type_;

    static const drive_type_ drive;

    // transit
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    transit_type_;

    static const transit_type_ transit;

    // wait
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    wait_type_;

    static const wait_type_ wait;

    // other
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    other_type_;

    static const other_type_ other;

    // length
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    length_type_;

    static const length_type_ length;

    // cost
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    cost_type_;

    static const cost_type_ cost;

    // impedance
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    impedance_type_;

    static const impedance_type_ impedance;

    // leg_mode
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    leg_mode_type_;

    static const leg_mode_type_ leg_mode;

    // leg_type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    leg_type_type_;

    static const leg_type_type_ leg_type;

    // leg_id
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    leg_id_type_;

    static const leg_id_type_ leg_id;

    // leg_time
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    leg_time_type_;

    static const leg_time_type_ leg_time;

    // leg_length
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    leg_length_type_;

    static const leg_length_type_ leg_length;

    // leg_cost
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    leg_cost_type_;

    static const leg_cost_type_ leg_cost;

    // leg_imp
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    leg_imp_type_;

    static const leg_imp_type_ leg_imp;
  };

  template <typename A>
  const typename query_columns< ::pio::Plan, A >::auto_id_type_
  query_columns< ::pio::Plan, A >::
  auto_id (A::table_name, "\"auto_id\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Plan, A >::depart_type_
  query_columns< ::pio::Plan, A >::
  depart (A::table_name, "\"depart\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Plan, A >::arrive_type_
  query_columns< ::pio::Plan, A >::
  arrive (A::table_name, "\"arrive\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Plan, A >::activity_type_
  query_columns< ::pio::Plan, A >::
  activity (A::table_name, "\"activity\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Plan, A >::walk_type_
  query_columns< ::pio::Plan, A >::
  walk (A::table_name, "\"walk\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Plan, A >::drive_type_
  query_columns< ::pio::Plan, A >::
  drive (A::table_name, "\"drive\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Plan, A >::transit_type_
  query_columns< ::pio::Plan, A >::
  transit (A::table_name, "\"transit\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Plan, A >::wait_type_
  query_columns< ::pio::Plan, A >::
  wait (A::table_name, "\"wait\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Plan, A >::other_type_
  query_columns< ::pio::Plan, A >::
  other (A::table_name, "\"other\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Plan, A >::length_type_
  query_columns< ::pio::Plan, A >::
  length (A::table_name, "\"length\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Plan, A >::cost_type_
  query_columns< ::pio::Plan, A >::
  cost (A::table_name, "\"cost\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Plan, A >::impedance_type_
  query_columns< ::pio::Plan, A >::
  impedance (A::table_name, "\"impedance\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Plan, A >::leg_mode_type_
  query_columns< ::pio::Plan, A >::
  leg_mode (A::table_name, "\"leg_mode\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Plan, A >::leg_type_type_
  query_columns< ::pio::Plan, A >::
  leg_type (A::table_name, "\"leg_type\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Plan, A >::leg_id_type_
  query_columns< ::pio::Plan, A >::
  leg_id (A::table_name, "\"leg_id\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Plan, A >::leg_time_type_
  query_columns< ::pio::Plan, A >::
  leg_time (A::table_name, "\"leg_time\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Plan, A >::leg_length_type_
  query_columns< ::pio::Plan, A >::
  leg_length (A::table_name, "\"leg_length\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Plan, A >::leg_cost_type_
  query_columns< ::pio::Plan, A >::
  leg_cost (A::table_name, "\"leg_cost\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Plan, A >::leg_imp_type_
  query_columns< ::pio::Plan, A >::
  leg_imp (A::table_name, "\"leg_imp\"", 0);

  template <typename A>
  struct pointer_query_columns< ::pio::Plan, A >:
    query_columns< ::pio::Plan, A >
  {
  };

  template <>
  class access::object_traits< ::pio::Plan >
  {
    public:
    typedef ::pio::Plan object_type;
    typedef ::std::tr1::shared_ptr< ::pio::Plan > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef long unsigned int id_type;
    static const bool auto_id = true;

    struct id_image_type
    {
      long long id_value;
      bool id_null;

      std::size_t version;
    };

    static const bool abstract = false;

    struct image_type
    {
      // auto_id
      //
      long long auto_id_value;
      bool auto_id_null;

      // depart
      //
      double depart_value;
      bool depart_null;

      // arrive
      //
      double arrive_value;
      bool arrive_null;

      // activity
      //
      double activity_value;
      bool activity_null;

      // walk
      //
      double walk_value;
      bool walk_null;

      // drive
      //
      double drive_value;
      bool drive_null;

      // transit
      //
      double transit_value;
      bool transit_null;

      // wait
      //
      double wait_value;
      bool wait_null;

      // other
      //
      double other_value;
      bool other_null;

      // length
      //
      double length_value;
      bool length_null;

      // cost
      //
      double cost_value;
      bool cost_null;

      // impedance
      //
      long long impedance_value;
      bool impedance_null;

      // leg_mode
      //
      long long leg_mode_value;
      bool leg_mode_null;

      // leg_type
      //
      long long leg_type_value;
      bool leg_type_null;

      // leg_id
      //
      long long leg_id_value;
      bool leg_id_null;

      // leg_time
      //
      double leg_time_value;
      bool leg_time_null;

      // leg_length
      //
      double leg_length_value;
      bool leg_length_null;

      // leg_cost
      //
      double leg_cost_value;
      bool leg_cost_null;

      // leg_imp
      //
      long long leg_imp_value;
      bool leg_imp_null;

      std::size_t version;
    };

    static id_type
    id (const object_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&, bool*);

    static void
    bind (sqlite::bind*,
          image_type&,
          sqlite::statement_kind);

    static void
    bind (sqlite::bind*, id_image_type&);

    static bool
    init (image_type&, const object_type&, sqlite::statement_kind);

    static void
    init (object_type&, const image_type&, database*);

    static void
    init (id_image_type&, const id_type&);

    typedef
    odb::pointer_cache_traits<pointer_type>
    pointer_cache_traits;
    typedef
    odb::reference_cache_traits<object_type>
    reference_cache_traits;

    typedef sqlite::object_statements<object_type> statements_type;

    typedef sqlite::query query_base_type;

    struct container_statement_cache_type;

    static const std::size_t column_count = 19UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static bool
    create_schema (database&, unsigned short pass, bool drop);

    public:
    static bool
    find_ (statements_type&, const id_type*);

    static void
    load_ (statements_type&, object_type&);
  };

  // Skim
  //
  template <>
  struct class_traits< ::pio::Skim >
  {
    static const class_kind kind = class_object;
  };

  template <typename A>
  struct query_columns< ::pio::Skim, A >
  {
    // auto_id
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        long unsigned int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    auto_id_type_;

    static const auto_id_type_ auto_id;

    // time
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    time_type_;

    static const time_type_ time;

    // walk
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    walk_type_;

    static const walk_type_ walk;

    // drive
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    drive_type_;

    static const drive_type_ drive;

    // transit
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    transit_type_;

    static const transit_type_ transit;

    // wait
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    wait_type_;

    static const wait_type_ wait;

    // other
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    other_type_;

    static const other_type_ other;

    // length
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    length_type_;

    static const length_type_ length;

    // cost
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    cost_type_;

    static const cost_type_ cost;

    // impedance
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    impedance_type_;

    static const impedance_type_ impedance;
  };

  template <typename A>
  const typename query_columns< ::pio::Skim, A >::auto_id_type_
  query_columns< ::pio::Skim, A >::
  auto_id (A::table_name, "\"auto_id\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Skim, A >::time_type_
  query_columns< ::pio::Skim, A >::
  time (A::table_name, "\"time\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Skim, A >::walk_type_
  query_columns< ::pio::Skim, A >::
  walk (A::table_name, "\"walk\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Skim, A >::drive_type_
  query_columns< ::pio::Skim, A >::
  drive (A::table_name, "\"drive\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Skim, A >::transit_type_
  query_columns< ::pio::Skim, A >::
  transit (A::table_name, "\"transit\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Skim, A >::wait_type_
  query_columns< ::pio::Skim, A >::
  wait (A::table_name, "\"wait\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Skim, A >::other_type_
  query_columns< ::pio::Skim, A >::
  other (A::table_name, "\"other\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Skim, A >::length_type_
  query_columns< ::pio::Skim, A >::
  length (A::table_name, "\"length\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Skim, A >::cost_type_
  query_columns< ::pio::Skim, A >::
  cost (A::table_name, "\"cost\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Skim, A >::impedance_type_
  query_columns< ::pio::Skim, A >::
  impedance (A::table_name, "\"impedance\"", 0);

  template <typename A>
  struct pointer_query_columns< ::pio::Skim, A >:
    query_columns< ::pio::Skim, A >
  {
  };

  template <>
  class access::object_traits< ::pio::Skim >
  {
    public:
    typedef ::pio::Skim object_type;
    typedef ::std::tr1::shared_ptr< ::pio::Skim > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef long unsigned int id_type;
    static const bool auto_id = true;

    struct id_image_type
    {
      long long id_value;
      bool id_null;

      std::size_t version;
    };

    static const bool abstract = false;

    struct image_type
    {
      // auto_id
      //
      long long auto_id_value;
      bool auto_id_null;

      // time
      //
      double time_value;
      bool time_null;

      // walk
      //
      double walk_value;
      bool walk_null;

      // drive
      //
      double drive_value;
      bool drive_null;

      // transit
      //
      double transit_value;
      bool transit_null;

      // wait
      //
      double wait_value;
      bool wait_null;

      // other
      //
      double other_value;
      bool other_null;

      // length
      //
      double length_value;
      bool length_null;

      // cost
      //
      double cost_value;
      bool cost_null;

      // impedance
      //
      long long impedance_value;
      bool impedance_null;

      std::size_t version;
    };

    static id_type
    id (const object_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&, bool*);

    static void
    bind (sqlite::bind*,
          image_type&,
          sqlite::statement_kind);

    static void
    bind (sqlite::bind*, id_image_type&);

    static bool
    init (image_type&, const object_type&, sqlite::statement_kind);

    static void
    init (object_type&, const image_type&, database*);

    static void
    init (id_image_type&, const id_type&);

    typedef
    odb::pointer_cache_traits<pointer_type>
    pointer_cache_traits;
    typedef
    odb::reference_cache_traits<object_type>
    reference_cache_traits;

    typedef sqlite::object_statements<object_type> statements_type;

    typedef sqlite::query query_base_type;

    struct container_statement_cache_type;

    static const std::size_t column_count = 10UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static bool
    create_schema (database&, unsigned short pass, bool drop);

    public:
    static bool
    find_ (statements_type&, const id_type*);

    static void
    load_ (statements_type&, object_type&);
  };

  // Event
  //
  template <>
  struct class_traits< ::pio::Event >
  {
    static const class_kind kind = class_object;
  };

  template <typename A>
  struct pointer_query_columns< ::pio::Event, A >
  {
    // auto_id
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        long unsigned int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    auto_id_type_;

    static const auto_id_type_ auto_id;

    // hhold
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    hhold_type_;

    static const hhold_type_ hhold;

    // person
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    person_type_;

    static const person_type_ person;

    // tour
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    tour_type_;

    static const tour_type_ tour;

    // trip
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    trip_type_;

    static const trip_type_ trip;

    // mode
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    mode_type_;

    static const mode_type_ mode;

    // type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    type_type_;

    static const type_type_ type;

    // schedule
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    schedule_type_;

    static const schedule_type_ schedule;

    // actual
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    actual_type_;

    static const actual_type_ actual;

    // link
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    link_type_;

    static const link_type_ link;

    // dir
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    dir_type_;

    static const dir_type_ dir;

    // lane
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    lane_type_;

    static const lane_type_ lane;

    // offset
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    offset_type_;

    static const offset_type_ offset;

    // route
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    route_type_;

    static const route_type_ route;
  };

  template <typename A>
  const typename pointer_query_columns< ::pio::Event, A >::auto_id_type_
  pointer_query_columns< ::pio::Event, A >::
  auto_id (A::table_name, "\"auto_id\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Event, A >::hhold_type_
  pointer_query_columns< ::pio::Event, A >::
  hhold (A::table_name, "\"hhold\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Event, A >::person_type_
  pointer_query_columns< ::pio::Event, A >::
  person (A::table_name, "\"person\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Event, A >::tour_type_
  pointer_query_columns< ::pio::Event, A >::
  tour (A::table_name, "\"tour\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Event, A >::trip_type_
  pointer_query_columns< ::pio::Event, A >::
  trip (A::table_name, "\"trip\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Event, A >::mode_type_
  pointer_query_columns< ::pio::Event, A >::
  mode (A::table_name, "\"mode\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Event, A >::type_type_
  pointer_query_columns< ::pio::Event, A >::
  type (A::table_name, "\"type\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Event, A >::schedule_type_
  pointer_query_columns< ::pio::Event, A >::
  schedule (A::table_name, "\"schedule\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Event, A >::actual_type_
  pointer_query_columns< ::pio::Event, A >::
  actual (A::table_name, "\"actual\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Event, A >::link_type_
  pointer_query_columns< ::pio::Event, A >::
  link (A::table_name, "\"link\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Event, A >::dir_type_
  pointer_query_columns< ::pio::Event, A >::
  dir (A::table_name, "\"dir\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Event, A >::lane_type_
  pointer_query_columns< ::pio::Event, A >::
  lane (A::table_name, "\"lane\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Event, A >::offset_type_
  pointer_query_columns< ::pio::Event, A >::
  offset (A::table_name, "\"offset\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Event, A >::route_type_
  pointer_query_columns< ::pio::Event, A >::
  route (A::table_name, "\"route\"", 0);

  template <>
  class access::object_traits< ::pio::Event >
  {
    public:
    typedef ::pio::Event object_type;
    typedef ::std::tr1::shared_ptr< ::pio::Event > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef long unsigned int id_type;
    static const bool auto_id = true;

    struct id_image_type
    {
      long long id_value;
      bool id_null;

      std::size_t version;
    };

    static const bool abstract = false;

    struct image_type
    {
      // auto_id
      //
      long long auto_id_value;
      bool auto_id_null;

      // hhold
      //
      long long hhold_value;
      bool hhold_null;

      // person
      //
      long long person_value;
      bool person_null;

      // tour
      //
      long long tour_value;
      bool tour_null;

      // trip
      //
      long long trip_value;
      bool trip_null;

      // mode
      //
      long long mode_value;
      bool mode_null;

      // type
      //
      long long type_value;
      bool type_null;

      // schedule
      //
      double schedule_value;
      bool schedule_null;

      // actual
      //
      double actual_value;
      bool actual_null;

      // link
      //
      long long link_value;
      bool link_null;

      // dir
      //
      long long dir_value;
      bool dir_null;

      // lane
      //
      long long lane_value;
      bool lane_null;

      // offset
      //
      double offset_value;
      bool offset_null;

      // route
      //
      long long route_value;
      bool route_null;

      std::size_t version;
    };

    static id_type
    id (const object_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&, bool*);

    static void
    bind (sqlite::bind*,
          image_type&,
          sqlite::statement_kind);

    static void
    bind (sqlite::bind*, id_image_type&);

    static bool
    init (image_type&, const object_type&, sqlite::statement_kind);

    static void
    init (object_type&, const image_type&, database*);

    static void
    init (id_image_type&, const id_type&);

    typedef
    odb::pointer_cache_traits<pointer_type>
    pointer_cache_traits;
    typedef
    odb::reference_cache_traits<object_type>
    reference_cache_traits;

    typedef sqlite::object_statements<object_type> statements_type;

    typedef sqlite::query query_base_type;

    struct container_statement_cache_type;

    static const std::size_t column_count = 14UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static bool
    create_schema (database&, unsigned short pass, bool drop);

    public:
    static bool
    find_ (statements_type&, const id_type*);

    static void
    load_ (statements_type&, object_type&);
  };

  // Traveler
  //
  template <>
  struct class_traits< ::pio::Traveler >
  {
    static const class_kind kind = class_object;
  };

  template <typename A>
  struct pointer_query_columns< ::pio::Traveler, A >
  {
    // auto_id
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        long unsigned int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    auto_id_type_;

    static const auto_id_type_ auto_id;

    // hhold
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    hhold_type_;

    static const hhold_type_ hhold;

    // person
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    person_type_;

    static const person_type_ person;

    // tour
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    tour_type_;

    static const tour_type_ tour;

    // trip
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    trip_type_;

    static const trip_type_ trip;

    // mode
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    mode_type_;

    static const mode_type_ mode;

    // time
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    time_type_;

    static const time_type_ time;

    // distance
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    distance_type_;

    static const distance_type_ distance;

    // speed
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    speed_type_;

    static const speed_type_ speed;

    // link
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    link_type_;

    static const link_type_ link;

    // dir
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    dir_type_;

    static const dir_type_ dir;

    // lane
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    lane_type_;

    static const lane_type_ lane;

    // offset
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    offset_type_;

    static const offset_type_ offset;

    // route
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    route_type_;

    static const route_type_ route;
  };

  template <typename A>
  const typename pointer_query_columns< ::pio::Traveler, A >::auto_id_type_
  pointer_query_columns< ::pio::Traveler, A >::
  auto_id (A::table_name, "\"auto_id\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Traveler, A >::hhold_type_
  pointer_query_columns< ::pio::Traveler, A >::
  hhold (A::table_name, "\"hhold\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Traveler, A >::person_type_
  pointer_query_columns< ::pio::Traveler, A >::
  person (A::table_name, "\"person\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Traveler, A >::tour_type_
  pointer_query_columns< ::pio::Traveler, A >::
  tour (A::table_name, "\"tour\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Traveler, A >::trip_type_
  pointer_query_columns< ::pio::Traveler, A >::
  trip (A::table_name, "\"trip\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Traveler, A >::mode_type_
  pointer_query_columns< ::pio::Traveler, A >::
  mode (A::table_name, "\"mode\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Traveler, A >::time_type_
  pointer_query_columns< ::pio::Traveler, A >::
  time (A::table_name, "\"time\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Traveler, A >::distance_type_
  pointer_query_columns< ::pio::Traveler, A >::
  distance (A::table_name, "\"distance\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Traveler, A >::speed_type_
  pointer_query_columns< ::pio::Traveler, A >::
  speed (A::table_name, "\"speed\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Traveler, A >::link_type_
  pointer_query_columns< ::pio::Traveler, A >::
  link (A::table_name, "\"link\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Traveler, A >::dir_type_
  pointer_query_columns< ::pio::Traveler, A >::
  dir (A::table_name, "\"dir\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Traveler, A >::lane_type_
  pointer_query_columns< ::pio::Traveler, A >::
  lane (A::table_name, "\"lane\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Traveler, A >::offset_type_
  pointer_query_columns< ::pio::Traveler, A >::
  offset (A::table_name, "\"offset\"", 0);

  template <typename A>
  const typename pointer_query_columns< ::pio::Traveler, A >::route_type_
  pointer_query_columns< ::pio::Traveler, A >::
  route (A::table_name, "\"route\"", 0);

  template <>
  class access::object_traits< ::pio::Traveler >
  {
    public:
    typedef ::pio::Traveler object_type;
    typedef ::std::tr1::shared_ptr< ::pio::Traveler > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef long unsigned int id_type;
    static const bool auto_id = true;

    struct id_image_type
    {
      long long id_value;
      bool id_null;

      std::size_t version;
    };

    static const bool abstract = false;

    struct image_type
    {
      // auto_id
      //
      long long auto_id_value;
      bool auto_id_null;

      // hhold
      //
      long long hhold_value;
      bool hhold_null;

      // person
      //
      long long person_value;
      bool person_null;

      // tour
      //
      long long tour_value;
      bool tour_null;

      // trip
      //
      long long trip_value;
      bool trip_null;

      // mode
      //
      long long mode_value;
      bool mode_null;

      // time
      //
      double time_value;
      bool time_null;

      // distance
      //
      double distance_value;
      bool distance_null;

      // speed
      //
      double speed_value;
      bool speed_null;

      // link
      //
      long long link_value;
      bool link_null;

      // dir
      //
      long long dir_value;
      bool dir_null;

      // lane
      //
      long long lane_value;
      bool lane_null;

      // offset
      //
      double offset_value;
      bool offset_null;

      // route
      //
      long long route_value;
      bool route_null;

      std::size_t version;
    };

    static id_type
    id (const object_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&, bool*);

    static void
    bind (sqlite::bind*,
          image_type&,
          sqlite::statement_kind);

    static void
    bind (sqlite::bind*, id_image_type&);

    static bool
    init (image_type&, const object_type&, sqlite::statement_kind);

    static void
    init (object_type&, const image_type&, database*);

    static void
    init (id_image_type&, const id_type&);

    typedef
    odb::pointer_cache_traits<pointer_type>
    pointer_cache_traits;
    typedef
    odb::reference_cache_traits<object_type>
    reference_cache_traits;

    typedef sqlite::object_statements<object_type> statements_type;

    typedef sqlite::query query_base_type;

    struct container_statement_cache_type;

    static const std::size_t column_count = 14UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static bool
    create_schema (database&, unsigned short pass, bool drop);

    public:
    static bool
    find_ (statements_type&, const id_type*);

    static void
    load_ (statements_type&, object_type&);
  };

  // TripNoRef
  //
  template <>
  struct class_traits< ::pio::TripNoRef >
  {
    static const class_kind kind = class_object;
  };

  template <typename A>
  struct query_columns< ::pio::TripNoRef, A >
  {
    // auto_id
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        long unsigned int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    auto_id_type_;

    static const auto_id_type_ auto_id;

    // hhold
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    hhold_type_;

    static const hhold_type_ hhold;

    // person
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    person_type_;

    static const person_type_ person;

    // tour
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    tour_type_;

    static const tour_type_ tour;

    // trip
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    trip_type_;

    static const trip_type_ trip;

    // start
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    start_type_;

    static const start_type_ start;

    // end
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    end_type_;

    static const end_type_ end;

    // duration
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    duration_type_;

    static const duration_type_ duration;

    // origin
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    origin_type_;

    static const origin_type_ origin;

    // destination
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    destination_type_;

    static const destination_type_ destination;

    // purpose
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    purpose_type_;

    static const purpose_type_ purpose;

    // mode
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    mode_type_;

    static const mode_type_ mode;

    // constraint
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    constraint_type_;

    static const constraint_type_ constraint;

    // priority
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    priority_type_;

    static const priority_type_ priority;

    // vehicle
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    vehicle_type_;

    static const vehicle_type_ vehicle;

    // passengers
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    passengers_type_;

    static const passengers_type_ passengers;

    // type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    type_type_;

    static const type_type_ type;

    // partition
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    partition_type_;

    static const partition_type_ partition;
  };

  template <typename A>
  const typename query_columns< ::pio::TripNoRef, A >::auto_id_type_
  query_columns< ::pio::TripNoRef, A >::
  auto_id (A::table_name, "\"auto_id\"", 0);

  template <typename A>
  const typename query_columns< ::pio::TripNoRef, A >::hhold_type_
  query_columns< ::pio::TripNoRef, A >::
  hhold (A::table_name, "\"hhold\"", 0);

  template <typename A>
  const typename query_columns< ::pio::TripNoRef, A >::person_type_
  query_columns< ::pio::TripNoRef, A >::
  person (A::table_name, "\"person\"", 0);

  template <typename A>
  const typename query_columns< ::pio::TripNoRef, A >::tour_type_
  query_columns< ::pio::TripNoRef, A >::
  tour (A::table_name, "\"tour\"", 0);

  template <typename A>
  const typename query_columns< ::pio::TripNoRef, A >::trip_type_
  query_columns< ::pio::TripNoRef, A >::
  trip (A::table_name, "\"trip\"", 0);

  template <typename A>
  const typename query_columns< ::pio::TripNoRef, A >::start_type_
  query_columns< ::pio::TripNoRef, A >::
  start (A::table_name, "\"start\"", 0);

  template <typename A>
  const typename query_columns< ::pio::TripNoRef, A >::end_type_
  query_columns< ::pio::TripNoRef, A >::
  end (A::table_name, "\"end\"", 0);

  template <typename A>
  const typename query_columns< ::pio::TripNoRef, A >::duration_type_
  query_columns< ::pio::TripNoRef, A >::
  duration (A::table_name, "\"duration\"", 0);

  template <typename A>
  const typename query_columns< ::pio::TripNoRef, A >::origin_type_
  query_columns< ::pio::TripNoRef, A >::
  origin (A::table_name, "\"origin\"", 0);

  template <typename A>
  const typename query_columns< ::pio::TripNoRef, A >::destination_type_
  query_columns< ::pio::TripNoRef, A >::
  destination (A::table_name, "\"destination\"", 0);

  template <typename A>
  const typename query_columns< ::pio::TripNoRef, A >::purpose_type_
  query_columns< ::pio::TripNoRef, A >::
  purpose (A::table_name, "\"purpose\"", 0);

  template <typename A>
  const typename query_columns< ::pio::TripNoRef, A >::mode_type_
  query_columns< ::pio::TripNoRef, A >::
  mode (A::table_name, "\"mode\"", 0);

  template <typename A>
  const typename query_columns< ::pio::TripNoRef, A >::constraint_type_
  query_columns< ::pio::TripNoRef, A >::
  constraint (A::table_name, "\"constraint\"", 0);

  template <typename A>
  const typename query_columns< ::pio::TripNoRef, A >::priority_type_
  query_columns< ::pio::TripNoRef, A >::
  priority (A::table_name, "\"priority\"", 0);

  template <typename A>
  const typename query_columns< ::pio::TripNoRef, A >::vehicle_type_
  query_columns< ::pio::TripNoRef, A >::
  vehicle (A::table_name, "\"vehicle\"", 0);

  template <typename A>
  const typename query_columns< ::pio::TripNoRef, A >::passengers_type_
  query_columns< ::pio::TripNoRef, A >::
  passengers (A::table_name, "\"passengers\"", 0);

  template <typename A>
  const typename query_columns< ::pio::TripNoRef, A >::type_type_
  query_columns< ::pio::TripNoRef, A >::
  type (A::table_name, "\"type\"", 0);

  template <typename A>
  const typename query_columns< ::pio::TripNoRef, A >::partition_type_
  query_columns< ::pio::TripNoRef, A >::
  partition (A::table_name, "\"partition\"", 0);

  template <typename A>
  struct pointer_query_columns< ::pio::TripNoRef, A >:
    query_columns< ::pio::TripNoRef, A >
  {
  };

  template <>
  class access::object_traits< ::pio::TripNoRef >
  {
    public:
    typedef ::pio::TripNoRef object_type;
    typedef ::std::tr1::shared_ptr< ::pio::TripNoRef > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef long unsigned int id_type;
    static const bool auto_id = true;

    struct id_image_type
    {
      long long id_value;
      bool id_null;

      std::size_t version;
    };

    static const bool abstract = false;

    struct image_type
    {
      // auto_id
      //
      long long auto_id_value;
      bool auto_id_null;

      // hhold
      //
      long long hhold_value;
      bool hhold_null;

      // person
      //
      long long person_value;
      bool person_null;

      // tour
      //
      long long tour_value;
      bool tour_null;

      // trip
      //
      long long trip_value;
      bool trip_null;

      // start
      //
      double start_value;
      bool start_null;

      // end
      //
      double end_value;
      bool end_null;

      // duration
      //
      double duration_value;
      bool duration_null;

      // origin
      //
      long long origin_value;
      bool origin_null;

      // destination
      //
      long long destination_value;
      bool destination_null;

      // purpose
      //
      long long purpose_value;
      bool purpose_null;

      // mode
      //
      long long mode_value;
      bool mode_null;

      // constraint
      //
      long long constraint_value;
      bool constraint_null;

      // priority
      //
      long long priority_value;
      bool priority_null;

      // vehicle
      //
      long long vehicle_value;
      bool vehicle_null;

      // passengers
      //
      long long passengers_value;
      bool passengers_null;

      // type
      //
      long long type_value;
      bool type_null;

      // partition
      //
      long long partition_value;
      bool partition_null;

      std::size_t version;
    };

    static id_type
    id (const object_type&);

    static id_type
    id (const image_type&);

    static bool
    grow (image_type&, bool*);

    static void
    bind (sqlite::bind*,
          image_type&,
          sqlite::statement_kind);

    static void
    bind (sqlite::bind*, id_image_type&);

    static bool
    init (image_type&, const object_type&, sqlite::statement_kind);

    static void
    init (object_type&, const image_type&, database*);

    static void
    init (id_image_type&, const id_type&);

    typedef
    odb::pointer_cache_traits<pointer_type>
    pointer_cache_traits;
    typedef
    odb::reference_cache_traits<object_type>
    reference_cache_traits;

    typedef sqlite::object_statements<object_type> statements_type;

    typedef sqlite::query query_base_type;

    struct container_statement_cache_type;

    static const std::size_t column_count = 18UL;
    static const std::size_t id_column_count = 1UL;
    static const std::size_t inverse_column_count = 0UL;
    static const std::size_t readonly_column_count = 0UL;
    static const std::size_t managed_optimistic_column_count = 0UL;

    static const char persist_statement[];
    static const char find_statement[];
    static const char update_statement[];
    static const char erase_statement[];
    static const char query_statement[];
    static const char erase_query_statement[];

    static const char table_name[];

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);

    static bool
    create_schema (database&, unsigned short pass, bool drop);

    public:
    static bool
    find_ (statements_type&, const id_type*);

    static void
    load_ (statements_type&, object_type&);
  };

  // Shape
  //
  class link_alias_tag;

#ifndef ODB_ALIAS_TRAITS_LINK_FOR_PIO_LINK
#define ODB_ALIAS_TRAITS_LINK_FOR_PIO_LINK
  template <bool d>
  struct alias_traits< ::pio::Link, link_alias_tag, d >
  {
    static const char table_name[];
  };

  template <bool d>
  const char alias_traits< ::pio::Link, link_alias_tag, d >::
  table_name[] = "\"link\"";
#endif // ODB_ALIAS_TRAITS_LINK_FOR_PIO_LINK

  template <>
  struct query_columns_base< ::pio::Shape >
  {
    // link
    //
    typedef
    odb::alias_traits< ::pio::Link, link_alias_tag >
    link_alias_;
  };

  template <typename A>
  struct query_columns< ::pio::Shape, A >:
    query_columns_base< ::pio::Shape >
  {
    // auto_id
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        long unsigned int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    auto_id_type_;

    static const auto_id_type_ auto_id;

    // link
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    link_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::pio::Link,
        link_alias_ > >
    link_pointer_type_;

    struct link_type_: link_pointer_type_, link_column_type_
    {
      link_type_ ()
      {
      }

      link_type_ (const char* t, const char* c, const char* conv)
        : link_column_type_ (t, c, conv)
      {
      }
    };

    static const link_type_ link;

    // points
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    points_type_;

    static const points_type_ points;
  };

  template <typename A>
  const typename query_columns< ::pio::Shape, A >::auto_id_type_
  query_columns< ::pio::Shape, A >::
  auto_id (A::table_name, "\"auto_id\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Shape, A >::link_type_
  query_columns< ::pio::Shape, A >::
  link (A::table_name, "\"link\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Shape, A >::points_type_
  query_columns< ::pio::Shape, A >::
  points (A::table_name, "\"points\"", 0);

  // Link
  //
  class node_a_alias_tag;

#ifndef ODB_ALIAS_TRAITS_NODE_A_FOR_PIO_NODE
#define ODB_ALIAS_TRAITS_NODE_A_FOR_PIO_NODE
  template <bool d>
  struct alias_traits< ::pio::Node, node_a_alias_tag, d >
  {
    static const char table_name[];
  };

  template <bool d>
  const char alias_traits< ::pio::Node, node_a_alias_tag, d >::
  table_name[] = "\"node_a\"";
#endif // ODB_ALIAS_TRAITS_NODE_A_FOR_PIO_NODE

  class node_b_alias_tag;

#ifndef ODB_ALIAS_TRAITS_NODE_B_FOR_PIO_NODE
#define ODB_ALIAS_TRAITS_NODE_B_FOR_PIO_NODE
  template <bool d>
  struct alias_traits< ::pio::Node, node_b_alias_tag, d >
  {
    static const char table_name[];
  };

  template <bool d>
  const char alias_traits< ::pio::Node, node_b_alias_tag, d >::
  table_name[] = "\"node_b\"";
#endif // ODB_ALIAS_TRAITS_NODE_B_FOR_PIO_NODE

  template <>
  struct query_columns_base< ::pio::Link >
  {
    // node_a
    //
    typedef
    odb::alias_traits< ::pio::Node, node_a_alias_tag >
    node_a_alias_;

    // node_b
    //
    typedef
    odb::alias_traits< ::pio::Node, node_b_alias_tag >
    node_b_alias_;
  };

  template <typename A>
  struct query_columns< ::pio::Link, A >:
    query_columns_base< ::pio::Link >
  {
    // link
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    link_type_;

    static const link_type_ link;

    // name
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        ::std::string,
        sqlite::id_text >::query_type,
      sqlite::id_text >
    name_type_;

    static const name_type_ name;

    // node_a
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    node_a_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::pio::Node,
        node_a_alias_ > >
    node_a_pointer_type_;

    struct node_a_type_: node_a_pointer_type_, node_a_column_type_
    {
      node_a_type_ ()
      {
      }

      node_a_type_ (const char* t, const char* c, const char* conv)
        : node_a_column_type_ (t, c, conv)
      {
      }
    };

    static const node_a_type_ node_a;

    // node_b
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    node_b_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::pio::Node,
        node_b_alias_ > >
    node_b_pointer_type_;

    struct node_b_type_: node_b_pointer_type_, node_b_column_type_
    {
      node_b_type_ ()
      {
      }

      node_b_type_ (const char* t, const char* c, const char* conv)
        : node_b_column_type_ (t, c, conv)
      {
      }
    };

    static const node_b_type_ node_b;

    // length
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    length_type_;

    static const length_type_ length;

    // setback_a
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    setback_a_type_;

    static const setback_a_type_ setback_a;

    // setback_b
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    setback_b_type_;

    static const setback_b_type_ setback_b;

    // bearing_a
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    bearing_a_type_;

    static const bearing_a_type_ bearing_a;

    // bearing_b
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    bearing_b_type_;

    static const bearing_b_type_ bearing_b;

    // type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        ::std::string,
        sqlite::id_text >::query_type,
      sqlite::id_text >
    type_type_;

    static const type_type_ type;

    // divided
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    divided_type_;

    static const divided_type_ divided;

    // area_type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    area_type_type_;

    static const area_type_type_ area_type;

    // use
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    use_type_;

    static const use_type_ use;

    // grade
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    grade_type_;

    static const grade_type_ grade;

    // lanes_ab
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    lanes_ab_type_;

    static const lanes_ab_type_ lanes_ab;

    // speed_ab
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    speed_ab_type_;

    static const speed_ab_type_ speed_ab;

    // fspd_ab
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    fspd_ab_type_;

    static const fspd_ab_type_ fspd_ab;

    // cap_ab
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    cap_ab_type_;

    static const cap_ab_type_ cap_ab;

    // lanes_ba
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    lanes_ba_type_;

    static const lanes_ba_type_ lanes_ba;

    // speed_ba
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    speed_ba_type_;

    static const speed_ba_type_ speed_ba;

    // fspd_ba
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    fspd_ba_type_;

    static const fspd_ba_type_ fspd_ba;

    // cap_ba
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    cap_ba_type_;

    static const cap_ba_type_ cap_ba;

    // left_ab
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    left_ab_type_;

    static const left_ab_type_ left_ab;

    // right_ab
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    right_ab_type_;

    static const right_ab_type_ right_ab;

    // left_ba
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    left_ba_type_;

    static const left_ba_type_ left_ba;

    // right_ba
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    right_ba_type_;

    static const right_ba_type_ right_ba;
  };

  template <typename A>
  const typename query_columns< ::pio::Link, A >::link_type_
  query_columns< ::pio::Link, A >::
  link (A::table_name, "\"link\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Link, A >::name_type_
  query_columns< ::pio::Link, A >::
  name (A::table_name, "\"name\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Link, A >::node_a_type_
  query_columns< ::pio::Link, A >::
  node_a (A::table_name, "\"node_a\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Link, A >::node_b_type_
  query_columns< ::pio::Link, A >::
  node_b (A::table_name, "\"node_b\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Link, A >::length_type_
  query_columns< ::pio::Link, A >::
  length (A::table_name, "\"length\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Link, A >::setback_a_type_
  query_columns< ::pio::Link, A >::
  setback_a (A::table_name, "\"setback_a\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Link, A >::setback_b_type_
  query_columns< ::pio::Link, A >::
  setback_b (A::table_name, "\"setback_b\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Link, A >::bearing_a_type_
  query_columns< ::pio::Link, A >::
  bearing_a (A::table_name, "\"bearing_a\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Link, A >::bearing_b_type_
  query_columns< ::pio::Link, A >::
  bearing_b (A::table_name, "\"bearing_b\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Link, A >::type_type_
  query_columns< ::pio::Link, A >::
  type (A::table_name, "\"type\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Link, A >::divided_type_
  query_columns< ::pio::Link, A >::
  divided (A::table_name, "\"divided\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Link, A >::area_type_type_
  query_columns< ::pio::Link, A >::
  area_type (A::table_name, "\"area_type\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Link, A >::use_type_
  query_columns< ::pio::Link, A >::
  use (A::table_name, "\"use\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Link, A >::grade_type_
  query_columns< ::pio::Link, A >::
  grade (A::table_name, "\"grade\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Link, A >::lanes_ab_type_
  query_columns< ::pio::Link, A >::
  lanes_ab (A::table_name, "\"lanes_ab\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Link, A >::speed_ab_type_
  query_columns< ::pio::Link, A >::
  speed_ab (A::table_name, "\"speed_ab\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Link, A >::fspd_ab_type_
  query_columns< ::pio::Link, A >::
  fspd_ab (A::table_name, "\"fspd_ab\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Link, A >::cap_ab_type_
  query_columns< ::pio::Link, A >::
  cap_ab (A::table_name, "\"cap_ab\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Link, A >::lanes_ba_type_
  query_columns< ::pio::Link, A >::
  lanes_ba (A::table_name, "\"lanes_ba\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Link, A >::speed_ba_type_
  query_columns< ::pio::Link, A >::
  speed_ba (A::table_name, "\"speed_ba\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Link, A >::fspd_ba_type_
  query_columns< ::pio::Link, A >::
  fspd_ba (A::table_name, "\"fspd_ba\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Link, A >::cap_ba_type_
  query_columns< ::pio::Link, A >::
  cap_ba (A::table_name, "\"cap_ba\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Link, A >::left_ab_type_
  query_columns< ::pio::Link, A >::
  left_ab (A::table_name, "\"left_ab\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Link, A >::right_ab_type_
  query_columns< ::pio::Link, A >::
  right_ab (A::table_name, "\"right_ab\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Link, A >::left_ba_type_
  query_columns< ::pio::Link, A >::
  left_ba (A::table_name, "\"left_ba\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Link, A >::right_ba_type_
  query_columns< ::pio::Link, A >::
  right_ba (A::table_name, "\"right_ba\"", 0);

  // Pocket
  //
  template <>
  struct query_columns_base< ::pio::Pocket >
  {
    // link
    //
    typedef
    odb::alias_traits< ::pio::Link, link_alias_tag >
    link_alias_;
  };

  template <typename A>
  struct query_columns< ::pio::Pocket, A >:
    query_columns_base< ::pio::Pocket >
  {
    // auto_id
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        long unsigned int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    auto_id_type_;

    static const auto_id_type_ auto_id;

    // link
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    link_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::pio::Link,
        link_alias_ > >
    link_pointer_type_;

    struct link_type_: link_pointer_type_, link_column_type_
    {
      link_type_ ()
      {
      }

      link_type_ (const char* t, const char* c, const char* conv)
        : link_column_type_ (t, c, conv)
      {
      }
    };

    static const link_type_ link;

    // dir
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    dir_type_;

    static const dir_type_ dir;

    // type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        ::std::string,
        sqlite::id_text >::query_type,
      sqlite::id_text >
    type_type_;

    static const type_type_ type;

    // lanes
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    lanes_type_;

    static const lanes_type_ lanes;

    // length
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    length_type_;

    static const length_type_ length;

    // offset
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    offset_type_;

    static const offset_type_ offset;
  };

  template <typename A>
  const typename query_columns< ::pio::Pocket, A >::auto_id_type_
  query_columns< ::pio::Pocket, A >::
  auto_id (A::table_name, "\"auto_id\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Pocket, A >::link_type_
  query_columns< ::pio::Pocket, A >::
  link (A::table_name, "\"link\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Pocket, A >::dir_type_
  query_columns< ::pio::Pocket, A >::
  dir (A::table_name, "\"dir\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Pocket, A >::type_type_
  query_columns< ::pio::Pocket, A >::
  type (A::table_name, "\"type\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Pocket, A >::lanes_type_
  query_columns< ::pio::Pocket, A >::
  lanes (A::table_name, "\"lanes\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Pocket, A >::length_type_
  query_columns< ::pio::Pocket, A >::
  length (A::table_name, "\"length\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Pocket, A >::offset_type_
  query_columns< ::pio::Pocket, A >::
  offset (A::table_name, "\"offset\"", 0);

  // Lane_Use
  //
  template <>
  struct query_columns_base< ::pio::Lane_Use >
  {
    // link
    //
    typedef
    odb::alias_traits< ::pio::Link, link_alias_tag >
    link_alias_;
  };

  template <typename A>
  struct query_columns< ::pio::Lane_Use, A >:
    query_columns_base< ::pio::Lane_Use >
  {
    // auto_id
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        long unsigned int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    auto_id_type_;

    static const auto_id_type_ auto_id;

    // link
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    link_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::pio::Link,
        link_alias_ > >
    link_pointer_type_;

    struct link_type_: link_pointer_type_, link_column_type_
    {
      link_type_ ()
      {
      }

      link_type_ (const char* t, const char* c, const char* conv)
        : link_column_type_ (t, c, conv)
      {
      }
    };

    static const link_type_ link;

    // dir
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    dir_type_;

    static const dir_type_ dir;

    // lanes
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    lanes_type_;

    static const lanes_type_ lanes;

    // use
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    use_type_;

    static const use_type_ use;

    // type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    type_type_;

    static const type_type_ type;

    // min_type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    min_type_type_;

    static const min_type_type_ min_type;

    // max_type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    max_type_type_;

    static const max_type_type_ max_type;

    // min_trav
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    min_trav_type_;

    static const min_trav_type_ min_trav;

    // max_trav
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    max_trav_type_;

    static const max_trav_type_ max_trav;

    // start
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    start_type_;

    static const start_type_ start;

    // end
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    end_type_;

    static const end_type_ end;

    // offset
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    offset_type_;

    static const offset_type_ offset;

    // length
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    length_type_;

    static const length_type_ length;

    // toll
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    toll_type_;

    static const toll_type_ toll;

    // rate
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    rate_type_;

    static const rate_type_ rate;

    // min_delay
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    min_delay_type_;

    static const min_delay_type_ min_delay;

    // max_delay
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    max_delay_type_;

    static const max_delay_type_ max_delay;
  };

  template <typename A>
  const typename query_columns< ::pio::Lane_Use, A >::auto_id_type_
  query_columns< ::pio::Lane_Use, A >::
  auto_id (A::table_name, "\"auto_id\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Lane_Use, A >::link_type_
  query_columns< ::pio::Lane_Use, A >::
  link (A::table_name, "\"link\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Lane_Use, A >::dir_type_
  query_columns< ::pio::Lane_Use, A >::
  dir (A::table_name, "\"dir\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Lane_Use, A >::lanes_type_
  query_columns< ::pio::Lane_Use, A >::
  lanes (A::table_name, "\"lanes\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Lane_Use, A >::use_type_
  query_columns< ::pio::Lane_Use, A >::
  use (A::table_name, "\"use\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Lane_Use, A >::type_type_
  query_columns< ::pio::Lane_Use, A >::
  type (A::table_name, "\"type\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Lane_Use, A >::min_type_type_
  query_columns< ::pio::Lane_Use, A >::
  min_type (A::table_name, "\"min_type\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Lane_Use, A >::max_type_type_
  query_columns< ::pio::Lane_Use, A >::
  max_type (A::table_name, "\"max_type\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Lane_Use, A >::min_trav_type_
  query_columns< ::pio::Lane_Use, A >::
  min_trav (A::table_name, "\"min_trav\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Lane_Use, A >::max_trav_type_
  query_columns< ::pio::Lane_Use, A >::
  max_trav (A::table_name, "\"max_trav\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Lane_Use, A >::start_type_
  query_columns< ::pio::Lane_Use, A >::
  start (A::table_name, "\"start\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Lane_Use, A >::end_type_
  query_columns< ::pio::Lane_Use, A >::
  end (A::table_name, "\"end\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Lane_Use, A >::offset_type_
  query_columns< ::pio::Lane_Use, A >::
  offset (A::table_name, "\"offset\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Lane_Use, A >::length_type_
  query_columns< ::pio::Lane_Use, A >::
  length (A::table_name, "\"length\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Lane_Use, A >::toll_type_
  query_columns< ::pio::Lane_Use, A >::
  toll (A::table_name, "\"toll\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Lane_Use, A >::rate_type_
  query_columns< ::pio::Lane_Use, A >::
  rate (A::table_name, "\"rate\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Lane_Use, A >::min_delay_type_
  query_columns< ::pio::Lane_Use, A >::
  min_delay (A::table_name, "\"min_delay\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Lane_Use, A >::max_delay_type_
  query_columns< ::pio::Lane_Use, A >::
  max_delay (A::table_name, "\"max_delay\"", 0);

  // Connect
  //
  class to_link_alias_tag;

#ifndef ODB_ALIAS_TRAITS_TO_LINK_FOR_PIO_LINK
#define ODB_ALIAS_TRAITS_TO_LINK_FOR_PIO_LINK
  template <bool d>
  struct alias_traits< ::pio::Link, to_link_alias_tag, d >
  {
    static const char table_name[];
  };

  template <bool d>
  const char alias_traits< ::pio::Link, to_link_alias_tag, d >::
  table_name[] = "\"to_link\"";
#endif // ODB_ALIAS_TRAITS_TO_LINK_FOR_PIO_LINK

  template <>
  struct query_columns_base< ::pio::Connect >
  {
    // link
    //
    typedef
    odb::alias_traits< ::pio::Link, link_alias_tag >
    link_alias_;

    // to_link
    //
    typedef
    odb::alias_traits< ::pio::Link, to_link_alias_tag >
    to_link_alias_;
  };

  template <typename A>
  struct query_columns< ::pio::Connect, A >:
    query_columns_base< ::pio::Connect >
  {
    // auto_id
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        long unsigned int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    auto_id_type_;

    static const auto_id_type_ auto_id;

    // link
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    link_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::pio::Link,
        link_alias_ > >
    link_pointer_type_;

    struct link_type_: link_pointer_type_, link_column_type_
    {
      link_type_ ()
      {
      }

      link_type_ (const char* t, const char* c, const char* conv)
        : link_column_type_ (t, c, conv)
      {
      }
    };

    static const link_type_ link;

    // dir
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    dir_type_;

    static const dir_type_ dir;

    // to_link
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    to_link_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::pio::Link,
        to_link_alias_ > >
    to_link_pointer_type_;

    struct to_link_type_: to_link_pointer_type_, to_link_column_type_
    {
      to_link_type_ ()
      {
      }

      to_link_type_ (const char* t, const char* c, const char* conv)
        : to_link_column_type_ (t, c, conv)
      {
      }
    };

    static const to_link_type_ to_link;

    // lanes
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        ::std::string,
        sqlite::id_text >::query_type,
      sqlite::id_text >
    lanes_type_;

    static const lanes_type_ lanes;

    // to_lanes
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        ::std::string,
        sqlite::id_text >::query_type,
      sqlite::id_text >
    to_lanes_type_;

    static const to_lanes_type_ to_lanes;

    // type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        ::std::string,
        sqlite::id_text >::query_type,
      sqlite::id_text >
    type_type_;

    static const type_type_ type;

    // penalty
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    penalty_type_;

    static const penalty_type_ penalty;

    // speed
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    speed_type_;

    static const speed_type_ speed;

    // capacity
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    capacity_type_;

    static const capacity_type_ capacity;

    // in_high
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    in_high_type_;

    static const in_high_type_ in_high;

    // out_high
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    out_high_type_;

    static const out_high_type_ out_high;
  };

  template <typename A>
  const typename query_columns< ::pio::Connect, A >::auto_id_type_
  query_columns< ::pio::Connect, A >::
  auto_id (A::table_name, "\"auto_id\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Connect, A >::link_type_
  query_columns< ::pio::Connect, A >::
  link (A::table_name, "\"link\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Connect, A >::dir_type_
  query_columns< ::pio::Connect, A >::
  dir (A::table_name, "\"dir\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Connect, A >::to_link_type_
  query_columns< ::pio::Connect, A >::
  to_link (A::table_name, "\"to_link\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Connect, A >::lanes_type_
  query_columns< ::pio::Connect, A >::
  lanes (A::table_name, "\"lanes\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Connect, A >::to_lanes_type_
  query_columns< ::pio::Connect, A >::
  to_lanes (A::table_name, "\"to_lanes\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Connect, A >::type_type_
  query_columns< ::pio::Connect, A >::
  type (A::table_name, "\"type\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Connect, A >::penalty_type_
  query_columns< ::pio::Connect, A >::
  penalty (A::table_name, "\"penalty\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Connect, A >::speed_type_
  query_columns< ::pio::Connect, A >::
  speed (A::table_name, "\"speed\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Connect, A >::capacity_type_
  query_columns< ::pio::Connect, A >::
  capacity (A::table_name, "\"capacity\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Connect, A >::in_high_type_
  query_columns< ::pio::Connect, A >::
  in_high (A::table_name, "\"in_high\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Connect, A >::out_high_type_
  query_columns< ::pio::Connect, A >::
  out_high (A::table_name, "\"out_high\"", 0);

  // Turn_Pen
  //
  class in_node_alias_tag;

#ifndef ODB_ALIAS_TRAITS_IN_NODE_FOR_PIO_NODE
#define ODB_ALIAS_TRAITS_IN_NODE_FOR_PIO_NODE
  template <bool d>
  struct alias_traits< ::pio::Node, in_node_alias_tag, d >
  {
    static const char table_name[];
  };

  template <bool d>
  const char alias_traits< ::pio::Node, in_node_alias_tag, d >::
  table_name[] = "\"in_node\"";
#endif // ODB_ALIAS_TRAITS_IN_NODE_FOR_PIO_NODE

  class out_node_alias_tag;

#ifndef ODB_ALIAS_TRAITS_OUT_NODE_FOR_PIO_NODE
#define ODB_ALIAS_TRAITS_OUT_NODE_FOR_PIO_NODE
  template <bool d>
  struct alias_traits< ::pio::Node, out_node_alias_tag, d >
  {
    static const char table_name[];
  };

  template <bool d>
  const char alias_traits< ::pio::Node, out_node_alias_tag, d >::
  table_name[] = "\"out_node\"";
#endif // ODB_ALIAS_TRAITS_OUT_NODE_FOR_PIO_NODE

  template <>
  struct query_columns_base< ::pio::Turn_Pen >
  {
    // link
    //
    typedef
    odb::alias_traits< ::pio::Link, link_alias_tag >
    link_alias_;

    // to_link
    //
    typedef
    odb::alias_traits< ::pio::Link, to_link_alias_tag >
    to_link_alias_;

    // in_node
    //
    typedef
    odb::alias_traits< ::pio::Node, in_node_alias_tag >
    in_node_alias_;

    // out_node
    //
    typedef
    odb::alias_traits< ::pio::Node, out_node_alias_tag >
    out_node_alias_;
  };

  template <typename A>
  struct query_columns< ::pio::Turn_Pen, A >:
    query_columns_base< ::pio::Turn_Pen >
  {
    // auto_id
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        long unsigned int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    auto_id_type_;

    static const auto_id_type_ auto_id;

    // link
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    link_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::pio::Link,
        link_alias_ > >
    link_pointer_type_;

    struct link_type_: link_pointer_type_, link_column_type_
    {
      link_type_ ()
      {
      }

      link_type_ (const char* t, const char* c, const char* conv)
        : link_column_type_ (t, c, conv)
      {
      }
    };

    static const link_type_ link;

    // dir
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    dir_type_;

    static const dir_type_ dir;

    // to_link
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    to_link_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::pio::Link,
        to_link_alias_ > >
    to_link_pointer_type_;

    struct to_link_type_: to_link_pointer_type_, to_link_column_type_
    {
      to_link_type_ ()
      {
      }

      to_link_type_ (const char* t, const char* c, const char* conv)
        : to_link_column_type_ (t, c, conv)
      {
      }
    };

    static const to_link_type_ to_link;

    // start
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    start_type_;

    static const start_type_ start;

    // end
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    end_type_;

    static const end_type_ end;

    // use
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    use_type_;

    static const use_type_ use;

    // min_type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    min_type_type_;

    static const min_type_type_ min_type;

    // max_type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    max_type_type_;

    static const max_type_type_ max_type;

    // penalty
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    penalty_type_;

    static const penalty_type_ penalty;

    // in_node
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    in_node_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::pio::Node,
        in_node_alias_ > >
    in_node_pointer_type_;

    struct in_node_type_: in_node_pointer_type_, in_node_column_type_
    {
      in_node_type_ ()
      {
      }

      in_node_type_ (const char* t, const char* c, const char* conv)
        : in_node_column_type_ (t, c, conv)
      {
      }
    };

    static const in_node_type_ in_node;

    // out_node
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    out_node_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::pio::Node,
        out_node_alias_ > >
    out_node_pointer_type_;

    struct out_node_type_: out_node_pointer_type_, out_node_column_type_
    {
      out_node_type_ ()
      {
      }

      out_node_type_ (const char* t, const char* c, const char* conv)
        : out_node_column_type_ (t, c, conv)
      {
      }
    };

    static const out_node_type_ out_node;
  };

  template <typename A>
  const typename query_columns< ::pio::Turn_Pen, A >::auto_id_type_
  query_columns< ::pio::Turn_Pen, A >::
  auto_id (A::table_name, "\"auto_id\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Turn_Pen, A >::link_type_
  query_columns< ::pio::Turn_Pen, A >::
  link (A::table_name, "\"link\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Turn_Pen, A >::dir_type_
  query_columns< ::pio::Turn_Pen, A >::
  dir (A::table_name, "\"dir\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Turn_Pen, A >::to_link_type_
  query_columns< ::pio::Turn_Pen, A >::
  to_link (A::table_name, "\"to_link\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Turn_Pen, A >::start_type_
  query_columns< ::pio::Turn_Pen, A >::
  start (A::table_name, "\"start\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Turn_Pen, A >::end_type_
  query_columns< ::pio::Turn_Pen, A >::
  end (A::table_name, "\"end\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Turn_Pen, A >::use_type_
  query_columns< ::pio::Turn_Pen, A >::
  use (A::table_name, "\"use\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Turn_Pen, A >::min_type_type_
  query_columns< ::pio::Turn_Pen, A >::
  min_type (A::table_name, "\"min_type\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Turn_Pen, A >::max_type_type_
  query_columns< ::pio::Turn_Pen, A >::
  max_type (A::table_name, "\"max_type\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Turn_Pen, A >::penalty_type_
  query_columns< ::pio::Turn_Pen, A >::
  penalty (A::table_name, "\"penalty\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Turn_Pen, A >::in_node_type_
  query_columns< ::pio::Turn_Pen, A >::
  in_node (A::table_name, "\"in_node\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Turn_Pen, A >::out_node_type_
  query_columns< ::pio::Turn_Pen, A >::
  out_node (A::table_name, "\"out_node\"", 0);

  // Parking
  //
  template <>
  struct query_columns_base< ::pio::Parking >
  {
    // link
    //
    typedef
    odb::alias_traits< ::pio::Link, link_alias_tag >
    link_alias_;
  };

  template <typename A>
  struct query_columns< ::pio::Parking, A >:
    query_columns_base< ::pio::Parking >
  {
    // parking
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    parking_type_;

    static const parking_type_ parking;

    // link
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    link_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::pio::Link,
        link_alias_ > >
    link_pointer_type_;

    struct link_type_: link_pointer_type_, link_column_type_
    {
      link_type_ ()
      {
      }

      link_type_ (const char* t, const char* c, const char* conv)
        : link_column_type_ (t, c, conv)
      {
      }
    };

    static const link_type_ link;

    // dir
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    dir_type_;

    static const dir_type_ dir;

    // offset
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    offset_type_;

    static const offset_type_ offset;

    // type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    type_type_;

    static const type_type_ type;

    // use
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    use_type_;

    static const use_type_ use;

    // start
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    start_type_;

    static const start_type_ start;

    // end
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    end_type_;

    static const end_type_ end;

    // space
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    space_type_;

    static const space_type_ space;

    // time_in
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    time_in_type_;

    static const time_in_type_ time_in;

    // time_out
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    time_out_type_;

    static const time_out_type_ time_out;

    // hourly
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    hourly_type_;

    static const hourly_type_ hourly;

    // daily
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    daily_type_;

    static const daily_type_ daily;
  };

  template <typename A>
  const typename query_columns< ::pio::Parking, A >::parking_type_
  query_columns< ::pio::Parking, A >::
  parking (A::table_name, "\"parking\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Parking, A >::link_type_
  query_columns< ::pio::Parking, A >::
  link (A::table_name, "\"link\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Parking, A >::dir_type_
  query_columns< ::pio::Parking, A >::
  dir (A::table_name, "\"dir\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Parking, A >::offset_type_
  query_columns< ::pio::Parking, A >::
  offset (A::table_name, "\"offset\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Parking, A >::type_type_
  query_columns< ::pio::Parking, A >::
  type (A::table_name, "\"type\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Parking, A >::use_type_
  query_columns< ::pio::Parking, A >::
  use (A::table_name, "\"use\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Parking, A >::start_type_
  query_columns< ::pio::Parking, A >::
  start (A::table_name, "\"start\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Parking, A >::end_type_
  query_columns< ::pio::Parking, A >::
  end (A::table_name, "\"end\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Parking, A >::space_type_
  query_columns< ::pio::Parking, A >::
  space (A::table_name, "\"space\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Parking, A >::time_in_type_
  query_columns< ::pio::Parking, A >::
  time_in (A::table_name, "\"time_in\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Parking, A >::time_out_type_
  query_columns< ::pio::Parking, A >::
  time_out (A::table_name, "\"time_out\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Parking, A >::hourly_type_
  query_columns< ::pio::Parking, A >::
  hourly (A::table_name, "\"hourly\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Parking, A >::daily_type_
  query_columns< ::pio::Parking, A >::
  daily (A::table_name, "\"daily\"", 0);

  // Location
  //
  class zone_alias_tag;

#ifndef ODB_ALIAS_TRAITS_ZONE_FOR_PIO_ZONE
#define ODB_ALIAS_TRAITS_ZONE_FOR_PIO_ZONE
  template <bool d>
  struct alias_traits< ::pio::Zone, zone_alias_tag, d >
  {
    static const char table_name[];
  };

  template <bool d>
  const char alias_traits< ::pio::Zone, zone_alias_tag, d >::
  table_name[] = "\"zone\"";
#endif // ODB_ALIAS_TRAITS_ZONE_FOR_PIO_ZONE

  template <>
  struct query_columns_base< ::pio::Location >
  {
    // link
    //
    typedef
    odb::alias_traits< ::pio::Link, link_alias_tag >
    link_alias_;

    // zone
    //
    typedef
    odb::alias_traits< ::pio::Zone, zone_alias_tag >
    zone_alias_;
  };

  template <typename A>
  struct query_columns< ::pio::Location, A >:
    query_columns_base< ::pio::Location >
  {
    // location
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    location_type_;

    static const location_type_ location;

    // link
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    link_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::pio::Link,
        link_alias_ > >
    link_pointer_type_;

    struct link_type_: link_pointer_type_, link_column_type_
    {
      link_type_ ()
      {
      }

      link_type_ (const char* t, const char* c, const char* conv)
        : link_column_type_ (t, c, conv)
      {
      }
    };

    static const link_type_ link;

    // dir
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    dir_type_;

    static const dir_type_ dir;

    // offset
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    offset_type_;

    static const offset_type_ offset;

    // setback
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    setback_type_;

    static const setback_type_ setback;

    // zone
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    zone_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::pio::Zone,
        zone_alias_ > >
    zone_pointer_type_;

    struct zone_type_: zone_pointer_type_, zone_column_type_
    {
      zone_type_ ()
      {
      }

      zone_type_ (const char* t, const char* c, const char* conv)
        : zone_column_type_ (t, c, conv)
      {
      }
    };

    static const zone_type_ zone;
  };

  template <typename A>
  const typename query_columns< ::pio::Location, A >::location_type_
  query_columns< ::pio::Location, A >::
  location (A::table_name, "\"location\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Location, A >::link_type_
  query_columns< ::pio::Location, A >::
  link (A::table_name, "\"link\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Location, A >::dir_type_
  query_columns< ::pio::Location, A >::
  dir (A::table_name, "\"dir\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Location, A >::offset_type_
  query_columns< ::pio::Location, A >::
  offset (A::table_name, "\"offset\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Location, A >::setback_type_
  query_columns< ::pio::Location, A >::
  setback (A::table_name, "\"setback\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Location, A >::zone_type_
  query_columns< ::pio::Location, A >::
  zone (A::table_name, "\"zone\"", 0);

  // Access
  //
  template <>
  struct query_columns_base< ::pio::Access >
  {
    // link
    //
    typedef
    odb::alias_traits< ::pio::Link, link_alias_tag >
    link_alias_;
  };

  template <typename A>
  struct query_columns< ::pio::Access, A >:
    query_columns_base< ::pio::Access >
  {
    // auto_id
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        long unsigned int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    auto_id_type_;

    static const auto_id_type_ auto_id;

    // link
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    link_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::pio::Link,
        link_alias_ > >
    link_pointer_type_;

    struct link_type_: link_pointer_type_, link_column_type_
    {
      link_type_ ()
      {
      }

      link_type_ (const char* t, const char* c, const char* conv)
        : link_column_type_ (t, c, conv)
      {
      }
    };

    static const link_type_ link;

    // from_id
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    from_id_type_;

    static const from_id_type_ from_id;

    // from_type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    from_type_type_;

    static const from_type_type_ from_type;

    // to_id
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    to_id_type_;

    static const to_id_type_ to_id;

    // to_type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    to_type_type_;

    static const to_type_type_ to_type;

    // dir
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    dir_type_;

    static const dir_type_ dir;

    // time
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    time_type_;

    static const time_type_ time;

    // cost
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    cost_type_;

    static const cost_type_ cost;
  };

  template <typename A>
  const typename query_columns< ::pio::Access, A >::auto_id_type_
  query_columns< ::pio::Access, A >::
  auto_id (A::table_name, "\"auto_id\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Access, A >::link_type_
  query_columns< ::pio::Access, A >::
  link (A::table_name, "\"link\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Access, A >::from_id_type_
  query_columns< ::pio::Access, A >::
  from_id (A::table_name, "\"from_id\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Access, A >::from_type_type_
  query_columns< ::pio::Access, A >::
  from_type (A::table_name, "\"from_type\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Access, A >::to_id_type_
  query_columns< ::pio::Access, A >::
  to_id (A::table_name, "\"to_id\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Access, A >::to_type_type_
  query_columns< ::pio::Access, A >::
  to_type (A::table_name, "\"to_type\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Access, A >::dir_type_
  query_columns< ::pio::Access, A >::
  dir (A::table_name, "\"dir\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Access, A >::time_type_
  query_columns< ::pio::Access, A >::
  time (A::table_name, "\"time\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Access, A >::cost_type_
  query_columns< ::pio::Access, A >::
  cost (A::table_name, "\"cost\"", 0);

  // Sign
  //
  template <>
  struct query_columns_base< ::pio::Sign >
  {
    // link
    //
    typedef
    odb::alias_traits< ::pio::Link, link_alias_tag >
    link_alias_;
  };

  template <typename A>
  struct query_columns< ::pio::Sign, A >:
    query_columns_base< ::pio::Sign >
  {
    // auto_id
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        long unsigned int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    auto_id_type_;

    static const auto_id_type_ auto_id;

    // link
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    link_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::pio::Link,
        link_alias_ > >
    link_pointer_type_;

    struct link_type_: link_pointer_type_, link_column_type_
    {
      link_type_ ()
      {
      }

      link_type_ (const char* t, const char* c, const char* conv)
        : link_column_type_ (t, c, conv)
      {
      }
    };

    static const link_type_ link;

    // dir
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    dir_type_;

    static const dir_type_ dir;

    // sign
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        ::std::string,
        sqlite::id_text >::query_type,
      sqlite::id_text >
    sign_type_;

    static const sign_type_ sign;
  };

  template <typename A>
  const typename query_columns< ::pio::Sign, A >::auto_id_type_
  query_columns< ::pio::Sign, A >::
  auto_id (A::table_name, "\"auto_id\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Sign, A >::link_type_
  query_columns< ::pio::Sign, A >::
  link (A::table_name, "\"link\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Sign, A >::dir_type_
  query_columns< ::pio::Sign, A >::
  dir (A::table_name, "\"dir\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Sign, A >::sign_type_
  query_columns< ::pio::Sign, A >::
  sign (A::table_name, "\"sign\"", 0);

  // Signal
  //
  class nodes_alias_tag;

#ifndef ODB_ALIAS_TRAITS_NODES_FOR_PIO_NODE
#define ODB_ALIAS_TRAITS_NODES_FOR_PIO_NODE
  template <bool d>
  struct alias_traits< ::pio::Node, nodes_alias_tag, d >
  {
    static const char table_name[];
  };

  template <bool d>
  const char alias_traits< ::pio::Node, nodes_alias_tag, d >::
  table_name[] = "\"nodes\"";
#endif // ODB_ALIAS_TRAITS_NODES_FOR_PIO_NODE

  template <>
  struct query_columns_base< ::pio::Signal >
  {
    // nodes
    //
    typedef
    odb::alias_traits< ::pio::Node, nodes_alias_tag >
    nodes_alias_;
  };

  template <typename A>
  struct query_columns< ::pio::Signal, A >:
    query_columns_base< ::pio::Signal >
  {
    // signal
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    signal_type_;

    static const signal_type_ signal;

    // group
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    group_type_;

    static const group_type_ group;

    // times
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    times_type_;

    static const times_type_ times;

    // nodes
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    nodes_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::pio::Node,
        nodes_alias_ > >
    nodes_pointer_type_;

    struct nodes_type_: nodes_pointer_type_, nodes_column_type_
    {
      nodes_type_ ()
      {
      }

      nodes_type_ (const char* t, const char* c, const char* conv)
        : nodes_column_type_ (t, c, conv)
      {
      }
    };

    static const nodes_type_ nodes;

    // type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        ::std::string,
        sqlite::id_text >::query_type,
      sqlite::id_text >
    type_type_;

    static const type_type_ type;

    // offset
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    offset_type_;

    static const offset_type_ offset;
  };

  template <typename A>
  const typename query_columns< ::pio::Signal, A >::signal_type_
  query_columns< ::pio::Signal, A >::
  signal (A::table_name, "\"signal\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Signal, A >::group_type_
  query_columns< ::pio::Signal, A >::
  group (A::table_name, "\"group\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Signal, A >::times_type_
  query_columns< ::pio::Signal, A >::
  times (A::table_name, "\"times\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Signal, A >::nodes_type_
  query_columns< ::pio::Signal, A >::
  nodes (A::table_name, "\"nodes\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Signal, A >::type_type_
  query_columns< ::pio::Signal, A >::
  type (A::table_name, "\"type\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Signal, A >::offset_type_
  query_columns< ::pio::Signal, A >::
  offset (A::table_name, "\"offset\"", 0);

  // Timing
  //
  class signal_alias_tag;

#ifndef ODB_ALIAS_TRAITS_SIGNAL_FOR_PIO_SIGNAL
#define ODB_ALIAS_TRAITS_SIGNAL_FOR_PIO_SIGNAL
  template <bool d>
  struct alias_traits< ::pio::Signal, signal_alias_tag, d >
  {
    static const char table_name[];
  };

  template <bool d>
  const char alias_traits< ::pio::Signal, signal_alias_tag, d >::
  table_name[] = "\"signal\"";
#endif // ODB_ALIAS_TRAITS_SIGNAL_FOR_PIO_SIGNAL

  template <>
  struct query_columns_base< ::pio::Timing >
  {
    // signal
    //
    typedef
    odb::alias_traits< ::pio::Signal, signal_alias_tag >
    signal_alias_;
  };

  template <typename A>
  struct query_columns< ::pio::Timing, A >:
    query_columns_base< ::pio::Timing >
  {
    // auto_id
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        long unsigned int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    auto_id_type_;

    static const auto_id_type_ auto_id;

    // signal
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    signal_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::pio::Signal,
        signal_alias_ > >
    signal_pointer_type_;

    struct signal_type_: signal_pointer_type_, signal_column_type_
    {
      signal_type_ ()
      {
      }

      signal_type_ (const char* t, const char* c, const char* conv)
        : signal_column_type_ (t, c, conv)
      {
      }
    };

    static const signal_type_ signal;

    // timing
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    timing_type_;

    static const timing_type_ timing;

    // type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    type_type_;

    static const type_type_ type;

    // cycle
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    cycle_type_;

    static const cycle_type_ cycle;

    // offset
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    offset_type_;

    static const offset_type_ offset;

    // phases
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    phases_type_;

    static const phases_type_ phases;
  };

  template <typename A>
  const typename query_columns< ::pio::Timing, A >::auto_id_type_
  query_columns< ::pio::Timing, A >::
  auto_id (A::table_name, "\"auto_id\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Timing, A >::signal_type_
  query_columns< ::pio::Timing, A >::
  signal (A::table_name, "\"signal\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Timing, A >::timing_type_
  query_columns< ::pio::Timing, A >::
  timing (A::table_name, "\"timing\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Timing, A >::type_type_
  query_columns< ::pio::Timing, A >::
  type (A::table_name, "\"type\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Timing, A >::cycle_type_
  query_columns< ::pio::Timing, A >::
  cycle (A::table_name, "\"cycle\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Timing, A >::offset_type_
  query_columns< ::pio::Timing, A >::
  offset (A::table_name, "\"offset\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Timing, A >::phases_type_
  query_columns< ::pio::Timing, A >::
  phases (A::table_name, "\"phases\"", 0);

  // Phasing
  //
  template <>
  struct query_columns_base< ::pio::Phasing >
  {
    // signal
    //
    typedef
    odb::alias_traits< ::pio::Signal, signal_alias_tag >
    signal_alias_;
  };

  template <typename A>
  struct query_columns< ::pio::Phasing, A >:
    query_columns_base< ::pio::Phasing >
  {
    // auto_id
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        long unsigned int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    auto_id_type_;

    static const auto_id_type_ auto_id;

    // signal
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    signal_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::pio::Signal,
        signal_alias_ > >
    signal_pointer_type_;

    struct signal_type_: signal_pointer_type_, signal_column_type_
    {
      signal_type_ ()
      {
      }

      signal_type_ (const char* t, const char* c, const char* conv)
        : signal_column_type_ (t, c, conv)
      {
      }
    };

    static const signal_type_ signal;

    // phasing
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    phasing_type_;

    static const phasing_type_ phasing;

    // phase
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    phase_type_;

    static const phase_type_ phase;

    // detectors
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        ::std::string,
        sqlite::id_text >::query_type,
      sqlite::id_text >
    detectors_type_;

    static const detectors_type_ detectors;

    // movements
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    movements_type_;

    static const movements_type_ movements;
  };

  template <typename A>
  const typename query_columns< ::pio::Phasing, A >::auto_id_type_
  query_columns< ::pio::Phasing, A >::
  auto_id (A::table_name, "\"auto_id\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Phasing, A >::signal_type_
  query_columns< ::pio::Phasing, A >::
  signal (A::table_name, "\"signal\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Phasing, A >::phasing_type_
  query_columns< ::pio::Phasing, A >::
  phasing (A::table_name, "\"phasing\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Phasing, A >::phase_type_
  query_columns< ::pio::Phasing, A >::
  phase (A::table_name, "\"phase\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Phasing, A >::detectors_type_
  query_columns< ::pio::Phasing, A >::
  detectors (A::table_name, "\"detectors\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Phasing, A >::movements_type_
  query_columns< ::pio::Phasing, A >::
  movements (A::table_name, "\"movements\"", 0);

  // Detector
  //
  template <>
  struct query_columns_base< ::pio::Detector >
  {
    // link
    //
    typedef
    odb::alias_traits< ::pio::Link, link_alias_tag >
    link_alias_;
  };

  template <typename A>
  struct query_columns< ::pio::Detector, A >:
    query_columns_base< ::pio::Detector >
  {
    // detector
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    detector_type_;

    static const detector_type_ detector;

    // link
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    link_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::pio::Link,
        link_alias_ > >
    link_pointer_type_;

    struct link_type_: link_pointer_type_, link_column_type_
    {
      link_type_ ()
      {
      }

      link_type_ (const char* t, const char* c, const char* conv)
        : link_column_type_ (t, c, conv)
      {
      }
    };

    static const link_type_ link;

    // dir
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    dir_type_;

    static const dir_type_ dir;

    // offset
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    offset_type_;

    static const offset_type_ offset;

    // length
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    length_type_;

    static const length_type_ length;

    // lanes
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    lanes_type_;

    static const lanes_type_ lanes;

    // type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    type_type_;

    static const type_type_ type;

    // use
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    use_type_;

    static const use_type_ use;

    // low
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    low_type_;

    static const low_type_ low;

    // high
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    high_type_;

    static const high_type_ high;
  };

  template <typename A>
  const typename query_columns< ::pio::Detector, A >::detector_type_
  query_columns< ::pio::Detector, A >::
  detector (A::table_name, "\"detector\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Detector, A >::link_type_
  query_columns< ::pio::Detector, A >::
  link (A::table_name, "\"link\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Detector, A >::dir_type_
  query_columns< ::pio::Detector, A >::
  dir (A::table_name, "\"dir\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Detector, A >::offset_type_
  query_columns< ::pio::Detector, A >::
  offset (A::table_name, "\"offset\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Detector, A >::length_type_
  query_columns< ::pio::Detector, A >::
  length (A::table_name, "\"length\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Detector, A >::lanes_type_
  query_columns< ::pio::Detector, A >::
  lanes (A::table_name, "\"lanes\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Detector, A >::type_type_
  query_columns< ::pio::Detector, A >::
  type (A::table_name, "\"type\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Detector, A >::use_type_
  query_columns< ::pio::Detector, A >::
  use (A::table_name, "\"use\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Detector, A >::low_type_
  query_columns< ::pio::Detector, A >::
  low (A::table_name, "\"low\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Detector, A >::high_type_
  query_columns< ::pio::Detector, A >::
  high (A::table_name, "\"high\"", 0);

  // Stop
  //
  template <>
  struct query_columns_base< ::pio::Stop >
  {
    // link
    //
    typedef
    odb::alias_traits< ::pio::Link, link_alias_tag >
    link_alias_;
  };

  template <typename A>
  struct query_columns< ::pio::Stop, A >:
    query_columns_base< ::pio::Stop >
  {
    // stop
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    stop_type_;

    static const stop_type_ stop;

    // name
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        ::std::string,
        sqlite::id_text >::query_type,
      sqlite::id_text >
    name_type_;

    static const name_type_ name;

    // link
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    link_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::pio::Link,
        link_alias_ > >
    link_pointer_type_;

    struct link_type_: link_pointer_type_, link_column_type_
    {
      link_type_ ()
      {
      }

      link_type_ (const char* t, const char* c, const char* conv)
        : link_column_type_ (t, c, conv)
      {
      }
    };

    static const link_type_ link;

    // dir
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    dir_type_;

    static const dir_type_ dir;

    // offset
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    offset_type_;

    static const offset_type_ offset;

    // use
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    use_type_;

    static const use_type_ use;

    // type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    type_type_;

    static const type_type_ type;

    // space
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    space_type_;

    static const space_type_ space;
  };

  template <typename A>
  const typename query_columns< ::pio::Stop, A >::stop_type_
  query_columns< ::pio::Stop, A >::
  stop (A::table_name, "\"stop\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Stop, A >::name_type_
  query_columns< ::pio::Stop, A >::
  name (A::table_name, "\"name\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Stop, A >::link_type_
  query_columns< ::pio::Stop, A >::
  link (A::table_name, "\"link\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Stop, A >::dir_type_
  query_columns< ::pio::Stop, A >::
  dir (A::table_name, "\"dir\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Stop, A >::offset_type_
  query_columns< ::pio::Stop, A >::
  offset (A::table_name, "\"offset\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Stop, A >::use_type_
  query_columns< ::pio::Stop, A >::
  use (A::table_name, "\"use\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Stop, A >::type_type_
  query_columns< ::pio::Stop, A >::
  type (A::table_name, "\"type\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Stop, A >::space_type_
  query_columns< ::pio::Stop, A >::
  space (A::table_name, "\"space\"", 0);

  // Fare
  //
  class from_zone_alias_tag;

#ifndef ODB_ALIAS_TRAITS_FROM_ZONE_FOR_PIO_ZONE
#define ODB_ALIAS_TRAITS_FROM_ZONE_FOR_PIO_ZONE
  template <bool d>
  struct alias_traits< ::pio::Zone, from_zone_alias_tag, d >
  {
    static const char table_name[];
  };

  template <bool d>
  const char alias_traits< ::pio::Zone, from_zone_alias_tag, d >::
  table_name[] = "\"from_zone\"";
#endif // ODB_ALIAS_TRAITS_FROM_ZONE_FOR_PIO_ZONE

  class to_zone_alias_tag;

#ifndef ODB_ALIAS_TRAITS_TO_ZONE_FOR_PIO_ZONE
#define ODB_ALIAS_TRAITS_TO_ZONE_FOR_PIO_ZONE
  template <bool d>
  struct alias_traits< ::pio::Zone, to_zone_alias_tag, d >
  {
    static const char table_name[];
  };

  template <bool d>
  const char alias_traits< ::pio::Zone, to_zone_alias_tag, d >::
  table_name[] = "\"to_zone\"";
#endif // ODB_ALIAS_TRAITS_TO_ZONE_FOR_PIO_ZONE

  template <>
  struct query_columns_base< ::pio::Fare >
  {
    // from_zone
    //
    typedef
    odb::alias_traits< ::pio::Zone, from_zone_alias_tag >
    from_zone_alias_;

    // to_zone
    //
    typedef
    odb::alias_traits< ::pio::Zone, to_zone_alias_tag >
    to_zone_alias_;
  };

  template <typename A>
  struct query_columns< ::pio::Fare, A >:
    query_columns_base< ::pio::Fare >
  {
    // from_zone
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    from_zone_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::pio::Zone,
        from_zone_alias_ > >
    from_zone_pointer_type_;

    struct from_zone_type_: from_zone_pointer_type_, from_zone_column_type_
    {
      from_zone_type_ ()
      {
      }

      from_zone_type_ (const char* t, const char* c, const char* conv)
        : from_zone_column_type_ (t, c, conv)
      {
      }
    };

    static const from_zone_type_ from_zone;

    // to_zone
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    to_zone_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::pio::Zone,
        to_zone_alias_ > >
    to_zone_pointer_type_;

    struct to_zone_type_: to_zone_pointer_type_, to_zone_column_type_
    {
      to_zone_type_ ()
      {
      }

      to_zone_type_ (const char* t, const char* c, const char* conv)
        : to_zone_column_type_ (t, c, conv)
      {
      }
    };

    static const to_zone_type_ to_zone;

    // from_mode
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    from_mode_type_;

    static const from_mode_type_ from_mode;

    // to_mode
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    to_mode_type_;

    static const to_mode_type_ to_mode;

    // period
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    period_type_;

    static const period_type_ period;

    // type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    type_type_;

    static const type_type_ type;

    // fare
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    fare_type_;

    static const fare_type_ fare;
  };

  template <typename A>
  const typename query_columns< ::pio::Fare, A >::from_zone_type_
  query_columns< ::pio::Fare, A >::
  from_zone (A::table_name, "\"from_zone\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Fare, A >::to_zone_type_
  query_columns< ::pio::Fare, A >::
  to_zone (A::table_name, "\"to_zone\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Fare, A >::from_mode_type_
  query_columns< ::pio::Fare, A >::
  from_mode (A::table_name, "\"from_mode\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Fare, A >::to_mode_type_
  query_columns< ::pio::Fare, A >::
  to_mode (A::table_name, "\"to_mode\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Fare, A >::period_type_
  query_columns< ::pio::Fare, A >::
  period (A::table_name, "\"period\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Fare, A >::type_type_
  query_columns< ::pio::Fare, A >::
  type (A::table_name, "\"type\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Fare, A >::fare_type_
  query_columns< ::pio::Fare, A >::
  fare (A::table_name, "\"fare\"", 0);

  // Line
  //
  class stops_alias_tag;

#ifndef ODB_ALIAS_TRAITS_STOPS_FOR_PIO_STOP
#define ODB_ALIAS_TRAITS_STOPS_FOR_PIO_STOP
  template <bool d>
  struct alias_traits< ::pio::Stop, stops_alias_tag, d >
  {
    static const char table_name[];
  };

  template <bool d>
  const char alias_traits< ::pio::Stop, stops_alias_tag, d >::
  table_name[] = "\"stops\"";
#endif // ODB_ALIAS_TRAITS_STOPS_FOR_PIO_STOP

  class stop_alias_tag;

#ifndef ODB_ALIAS_TRAITS_STOP_FOR_PIO_STOP
#define ODB_ALIAS_TRAITS_STOP_FOR_PIO_STOP
  template <bool d>
  struct alias_traits< ::pio::Stop, stop_alias_tag, d >
  {
    static const char table_name[];
  };

  template <bool d>
  const char alias_traits< ::pio::Stop, stop_alias_tag, d >::
  table_name[] = "\"stop\"";
#endif // ODB_ALIAS_TRAITS_STOP_FOR_PIO_STOP

  template <>
  struct query_columns_base< ::pio::Line >
  {
    // stops
    //
    typedef
    odb::alias_traits< ::pio::Stop, stops_alias_tag >
    stops_alias_;

    // stop
    //
    typedef
    odb::alias_traits< ::pio::Stop, stop_alias_tag >
    stop_alias_;

    // zone
    //
    typedef
    odb::alias_traits< ::pio::Zone, zone_alias_tag >
    zone_alias_;
  };

  template <typename A>
  struct query_columns< ::pio::Line, A >:
    query_columns_base< ::pio::Line >
  {
    // auto_id
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        long unsigned int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    auto_id_type_;

    static const auto_id_type_ auto_id;

    // route
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    route_type_;

    static const route_type_ route;

    // stops
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    stops_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::pio::Stop,
        stops_alias_ > >
    stops_pointer_type_;

    struct stops_type_: stops_pointer_type_, stops_column_type_
    {
      stops_type_ ()
      {
      }

      stops_type_ (const char* t, const char* c, const char* conv)
        : stops_column_type_ (t, c, conv)
      {
      }
    };

    static const stops_type_ stops;

    // mode
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    mode_type_;

    static const mode_type_ mode;

    // type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    type_type_;

    static const type_type_ type;

    // name
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        ::std::string,
        sqlite::id_text >::query_type,
      sqlite::id_text >
    name_type_;

    static const name_type_ name;

    // stop
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    stop_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::pio::Stop,
        stop_alias_ > >
    stop_pointer_type_;

    struct stop_type_: stop_pointer_type_, stop_column_type_
    {
      stop_type_ ()
      {
      }

      stop_type_ (const char* t, const char* c, const char* conv)
        : stop_column_type_ (t, c, conv)
      {
      }
    };

    static const stop_type_ stop;

    // zone
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    zone_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::pio::Zone,
        zone_alias_ > >
    zone_pointer_type_;

    struct zone_type_: zone_pointer_type_, zone_column_type_
    {
      zone_type_ ()
      {
      }

      zone_type_ (const char* t, const char* c, const char* conv)
        : zone_column_type_ (t, c, conv)
      {
      }
    };

    static const zone_type_ zone;

    // flag
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    flag_type_;

    static const flag_type_ flag;
  };

  template <typename A>
  const typename query_columns< ::pio::Line, A >::auto_id_type_
  query_columns< ::pio::Line, A >::
  auto_id (A::table_name, "\"auto_id\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Line, A >::route_type_
  query_columns< ::pio::Line, A >::
  route (A::table_name, "\"route\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Line, A >::stops_type_
  query_columns< ::pio::Line, A >::
  stops (A::table_name, "\"stops\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Line, A >::mode_type_
  query_columns< ::pio::Line, A >::
  mode (A::table_name, "\"mode\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Line, A >::type_type_
  query_columns< ::pio::Line, A >::
  type (A::table_name, "\"type\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Line, A >::name_type_
  query_columns< ::pio::Line, A >::
  name (A::table_name, "\"name\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Line, A >::stop_type_
  query_columns< ::pio::Line, A >::
  stop (A::table_name, "\"stop\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Line, A >::zone_type_
  query_columns< ::pio::Line, A >::
  zone (A::table_name, "\"zone\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Line, A >::flag_type_
  query_columns< ::pio::Line, A >::
  flag (A::table_name, "\"flag\"", 0);

  // Schedule
  //
  template <>
  struct query_columns_base< ::pio::Schedule >
  {
    // stops
    //
    typedef
    odb::alias_traits< ::pio::Stop, stops_alias_tag >
    stops_alias_;

    // stop
    //
    typedef
    odb::alias_traits< ::pio::Stop, stop_alias_tag >
    stop_alias_;
  };

  template <typename A>
  struct query_columns< ::pio::Schedule, A >:
    query_columns_base< ::pio::Schedule >
  {
    // auto_id
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        long unsigned int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    auto_id_type_;

    static const auto_id_type_ auto_id;

    // route
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    route_type_;

    static const route_type_ route;

    // stops
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    stops_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::pio::Stop,
        stops_alias_ > >
    stops_pointer_type_;

    struct stops_type_: stops_pointer_type_, stops_column_type_
    {
      stops_type_ ()
      {
      }

      stops_type_ (const char* t, const char* c, const char* conv)
        : stops_column_type_ (t, c, conv)
      {
      }
    };

    static const stops_type_ stops;

    // stop
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    stop_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::pio::Stop,
        stop_alias_ > >
    stop_pointer_type_;

    struct stop_type_: stop_pointer_type_, stop_column_type_
    {
      stop_type_ ()
      {
      }

      stop_type_ (const char* t, const char* c, const char* conv)
        : stop_column_type_ (t, c, conv)
      {
      }
    };

    static const stop_type_ stop;
  };

  template <typename A>
  const typename query_columns< ::pio::Schedule, A >::auto_id_type_
  query_columns< ::pio::Schedule, A >::
  auto_id (A::table_name, "\"auto_id\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Schedule, A >::route_type_
  query_columns< ::pio::Schedule, A >::
  route (A::table_name, "\"route\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Schedule, A >::stops_type_
  query_columns< ::pio::Schedule, A >::
  stops (A::table_name, "\"stops\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Schedule, A >::stop_type_
  query_columns< ::pio::Schedule, A >::
  stop (A::table_name, "\"stop\"", 0);

  // Driver
  //
  class links_alias_tag;

#ifndef ODB_ALIAS_TRAITS_LINKS_FOR_PIO_LINK
#define ODB_ALIAS_TRAITS_LINKS_FOR_PIO_LINK
  template <bool d>
  struct alias_traits< ::pio::Link, links_alias_tag, d >
  {
    static const char table_name[];
  };

  template <bool d>
  const char alias_traits< ::pio::Link, links_alias_tag, d >::
  table_name[] = "\"links\"";
#endif // ODB_ALIAS_TRAITS_LINKS_FOR_PIO_LINK

  template <>
  struct query_columns_base< ::pio::Driver >
  {
    // links
    //
    typedef
    odb::alias_traits< ::pio::Link, links_alias_tag >
    links_alias_;

    // link
    //
    typedef
    odb::alias_traits< ::pio::Link, link_alias_tag >
    link_alias_;
  };

  template <typename A>
  struct query_columns< ::pio::Driver, A >:
    query_columns_base< ::pio::Driver >
  {
    // auto_id
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        long unsigned int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    auto_id_type_;

    static const auto_id_type_ auto_id;

    // route
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    route_type_;

    static const route_type_ route;

    // links
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    links_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::pio::Link,
        links_alias_ > >
    links_pointer_type_;

    struct links_type_: links_pointer_type_, links_column_type_
    {
      links_type_ ()
      {
      }

      links_type_ (const char* t, const char* c, const char* conv)
        : links_column_type_ (t, c, conv)
      {
      }
    };

    static const links_type_ links;

    // type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    type_type_;

    static const type_type_ type;

    // subtype
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    subtype_type_;

    static const subtype_type_ subtype;

    // link
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    link_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::pio::Link,
        link_alias_ > >
    link_pointer_type_;

    struct link_type_: link_pointer_type_, link_column_type_
    {
      link_type_ ()
      {
      }

      link_type_ (const char* t, const char* c, const char* conv)
        : link_column_type_ (t, c, conv)
      {
      }
    };

    static const link_type_ link;

    // dir
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    dir_type_;

    static const dir_type_ dir;
  };

  template <typename A>
  const typename query_columns< ::pio::Driver, A >::auto_id_type_
  query_columns< ::pio::Driver, A >::
  auto_id (A::table_name, "\"auto_id\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Driver, A >::route_type_
  query_columns< ::pio::Driver, A >::
  route (A::table_name, "\"route\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Driver, A >::links_type_
  query_columns< ::pio::Driver, A >::
  links (A::table_name, "\"links\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Driver, A >::type_type_
  query_columns< ::pio::Driver, A >::
  type (A::table_name, "\"type\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Driver, A >::subtype_type_
  query_columns< ::pio::Driver, A >::
  subtype (A::table_name, "\"subtype\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Driver, A >::link_type_
  query_columns< ::pio::Driver, A >::
  link (A::table_name, "\"link\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Driver, A >::dir_type_
  query_columns< ::pio::Driver, A >::
  dir (A::table_name, "\"dir\"", 0);

  // Route_Nodes
  //
  class veh_type_alias_tag;

#ifndef ODB_ALIAS_TRAITS_VEH_TYPE_FOR_PIO_VEH_TYPE
#define ODB_ALIAS_TRAITS_VEH_TYPE_FOR_PIO_VEH_TYPE
  template <bool d>
  struct alias_traits< ::pio::Veh_Type, veh_type_alias_tag, d >
  {
    static const char table_name[];
  };

  template <bool d>
  const char alias_traits< ::pio::Veh_Type, veh_type_alias_tag, d >::
  table_name[] = "\"veh_type\"";
#endif // ODB_ALIAS_TRAITS_VEH_TYPE_FOR_PIO_VEH_TYPE

  class node_alias_tag;

#ifndef ODB_ALIAS_TRAITS_NODE_FOR_PIO_NODE
#define ODB_ALIAS_TRAITS_NODE_FOR_PIO_NODE
  template <bool d>
  struct alias_traits< ::pio::Node, node_alias_tag, d >
  {
    static const char table_name[];
  };

  template <bool d>
  const char alias_traits< ::pio::Node, node_alias_tag, d >::
  table_name[] = "\"node\"";
#endif // ODB_ALIAS_TRAITS_NODE_FOR_PIO_NODE

  template <>
  struct query_columns_base< ::pio::Route_Nodes >
  {
    // veh_type
    //
    typedef
    odb::alias_traits< ::pio::Veh_Type, veh_type_alias_tag >
    veh_type_alias_;

    // nodes
    //
    typedef
    odb::alias_traits< ::pio::Node, nodes_alias_tag >
    nodes_alias_;

    // node
    //
    typedef
    odb::alias_traits< ::pio::Node, node_alias_tag >
    node_alias_;
  };

  template <typename A>
  struct query_columns< ::pio::Route_Nodes, A >:
    query_columns_base< ::pio::Route_Nodes >
  {
    // auto_id
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        long unsigned int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    auto_id_type_;

    static const auto_id_type_ auto_id;

    // route
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    route_type_;

    static const route_type_ route;

    // mode
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    mode_type_;

    static const mode_type_ mode;

    // veh_type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    veh_type_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::pio::Veh_Type,
        veh_type_alias_ > >
    veh_type_pointer_type_;

    struct veh_type_type_: veh_type_pointer_type_, veh_type_column_type_
    {
      veh_type_type_ ()
      {
      }

      veh_type_type_ (const char* t, const char* c, const char* conv)
        : veh_type_column_type_ (t, c, conv)
      {
      }
    };

    static const veh_type_type_ veh_type;

    // nodes
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    nodes_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::pio::Node,
        nodes_alias_ > >
    nodes_pointer_type_;

    struct nodes_type_: nodes_pointer_type_, nodes_column_type_
    {
      nodes_type_ ()
      {
      }

      nodes_type_ (const char* t, const char* c, const char* conv)
        : nodes_column_type_ (t, c, conv)
      {
      }
    };

    static const nodes_type_ nodes;

    // name
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        ::std::string,
        sqlite::id_text >::query_type,
      sqlite::id_text >
    name_type_;

    static const name_type_ name;

    // node
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    node_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::pio::Node,
        node_alias_ > >
    node_pointer_type_;

    struct node_type_: node_pointer_type_, node_column_type_
    {
      node_type_ ()
      {
      }

      node_type_ (const char* t, const char* c, const char* conv)
        : node_column_type_ (t, c, conv)
      {
      }
    };

    static const node_type_ node;

    // type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    type_type_;

    static const type_type_ type;

    // dwell
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    dwell_type_;

    static const dwell_type_ dwell;

    // time
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    time_type_;

    static const time_type_ time;

    // speed
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    speed_type_;

    static const speed_type_ speed;
  };

  template <typename A>
  const typename query_columns< ::pio::Route_Nodes, A >::auto_id_type_
  query_columns< ::pio::Route_Nodes, A >::
  auto_id (A::table_name, "\"auto_id\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Route_Nodes, A >::route_type_
  query_columns< ::pio::Route_Nodes, A >::
  route (A::table_name, "\"route\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Route_Nodes, A >::mode_type_
  query_columns< ::pio::Route_Nodes, A >::
  mode (A::table_name, "\"mode\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Route_Nodes, A >::veh_type_type_
  query_columns< ::pio::Route_Nodes, A >::
  veh_type (A::table_name, "\"veh_type\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Route_Nodes, A >::nodes_type_
  query_columns< ::pio::Route_Nodes, A >::
  nodes (A::table_name, "\"nodes\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Route_Nodes, A >::name_type_
  query_columns< ::pio::Route_Nodes, A >::
  name (A::table_name, "\"name\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Route_Nodes, A >::node_type_
  query_columns< ::pio::Route_Nodes, A >::
  node (A::table_name, "\"node\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Route_Nodes, A >::type_type_
  query_columns< ::pio::Route_Nodes, A >::
  type (A::table_name, "\"type\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Route_Nodes, A >::dwell_type_
  query_columns< ::pio::Route_Nodes, A >::
  dwell (A::table_name, "\"dwell\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Route_Nodes, A >::time_type_
  query_columns< ::pio::Route_Nodes, A >::
  time (A::table_name, "\"time\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Route_Nodes, A >::speed_type_
  query_columns< ::pio::Route_Nodes, A >::
  speed (A::table_name, "\"speed\"", 0);

  // Household
  //
  class location_alias_tag;

#ifndef ODB_ALIAS_TRAITS_LOCATION_FOR_PIO_LOCATION
#define ODB_ALIAS_TRAITS_LOCATION_FOR_PIO_LOCATION
  template <bool d>
  struct alias_traits< ::pio::Location, location_alias_tag, d >
  {
    static const char table_name[];
  };

  template <bool d>
  const char alias_traits< ::pio::Location, location_alias_tag, d >::
  table_name[] = "\"location\"";
#endif // ODB_ALIAS_TRAITS_LOCATION_FOR_PIO_LOCATION

  template <>
  struct query_columns_base< ::pio::Household >
  {
    // location
    //
    typedef
    odb::alias_traits< ::pio::Location, location_alias_tag >
    location_alias_;
  };

  template <typename A>
  struct query_columns< ::pio::Household, A >:
    query_columns_base< ::pio::Household >
  {
    // auto_id
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        long unsigned int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    auto_id_type_;

    static const auto_id_type_ auto_id;

    // hhold
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    hhold_type_;

    static const hhold_type_ hhold;

    // location
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    location_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::pio::Location,
        location_alias_ > >
    location_pointer_type_;

    struct location_type_: location_pointer_type_, location_column_type_
    {
      location_type_ ()
      {
      }

      location_type_ (const char* t, const char* c, const char* conv)
        : location_column_type_ (t, c, conv)
      {
      }
    };

    static const location_type_ location;

    // persons
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    persons_type_;

    static const persons_type_ persons;

    // workers
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    workers_type_;

    static const workers_type_ workers;

    // vehicles
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    vehicles_type_;

    static const vehicles_type_ vehicles;

    // type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    type_type_;

    static const type_type_ type;

    // partition
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    partition_type_;

    static const partition_type_ partition;

    // person
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    person_type_;

    static const person_type_ person;

    // age
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    age_type_;

    static const age_type_ age;

    // relate
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    relate_type_;

    static const relate_type_ relate;

    // gender
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    gender_type_;

    static const gender_type_ gender;

    // work
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    work_type_;

    static const work_type_ work;

    // drive
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    drive_type_;

    static const drive_type_ drive;
  };

  template <typename A>
  const typename query_columns< ::pio::Household, A >::auto_id_type_
  query_columns< ::pio::Household, A >::
  auto_id (A::table_name, "\"auto_id\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Household, A >::hhold_type_
  query_columns< ::pio::Household, A >::
  hhold (A::table_name, "\"hhold\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Household, A >::location_type_
  query_columns< ::pio::Household, A >::
  location (A::table_name, "\"location\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Household, A >::persons_type_
  query_columns< ::pio::Household, A >::
  persons (A::table_name, "\"persons\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Household, A >::workers_type_
  query_columns< ::pio::Household, A >::
  workers (A::table_name, "\"workers\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Household, A >::vehicles_type_
  query_columns< ::pio::Household, A >::
  vehicles (A::table_name, "\"vehicles\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Household, A >::type_type_
  query_columns< ::pio::Household, A >::
  type (A::table_name, "\"type\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Household, A >::partition_type_
  query_columns< ::pio::Household, A >::
  partition (A::table_name, "\"partition\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Household, A >::person_type_
  query_columns< ::pio::Household, A >::
  person (A::table_name, "\"person\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Household, A >::age_type_
  query_columns< ::pio::Household, A >::
  age (A::table_name, "\"age\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Household, A >::relate_type_
  query_columns< ::pio::Household, A >::
  relate (A::table_name, "\"relate\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Household, A >::gender_type_
  query_columns< ::pio::Household, A >::
  gender (A::table_name, "\"gender\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Household, A >::work_type_
  query_columns< ::pio::Household, A >::
  work (A::table_name, "\"work\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Household, A >::drive_type_
  query_columns< ::pio::Household, A >::
  drive (A::table_name, "\"drive\"", 0);

  // Link_Delay
  //
  class out_link_alias_tag;

#ifndef ODB_ALIAS_TRAITS_OUT_LINK_FOR_PIO_LINK
#define ODB_ALIAS_TRAITS_OUT_LINK_FOR_PIO_LINK
  template <bool d>
  struct alias_traits< ::pio::Link, out_link_alias_tag, d >
  {
    static const char table_name[];
  };

  template <bool d>
  const char alias_traits< ::pio::Link, out_link_alias_tag, d >::
  table_name[] = "\"out_link\"";
#endif // ODB_ALIAS_TRAITS_OUT_LINK_FOR_PIO_LINK

  template <>
  struct query_columns_base< ::pio::Link_Delay >
  {
    // link
    //
    typedef
    odb::alias_traits< ::pio::Link, link_alias_tag >
    link_alias_;

    // out_link
    //
    typedef
    odb::alias_traits< ::pio::Link, out_link_alias_tag >
    out_link_alias_;
  };

  template <typename A>
  struct query_columns< ::pio::Link_Delay, A >:
    query_columns_base< ::pio::Link_Delay >
  {
    // auto_id
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        long unsigned int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    auto_id_type_;

    static const auto_id_type_ auto_id;

    // link
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    link_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::pio::Link,
        link_alias_ > >
    link_pointer_type_;

    struct link_type_: link_pointer_type_, link_column_type_
    {
      link_type_ ()
      {
      }

      link_type_ (const char* t, const char* c, const char* conv)
        : link_column_type_ (t, c, conv)
      {
      }
    };

    static const link_type_ link;

    // dir
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    dir_type_;

    static const dir_type_ dir;

    // type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    type_type_;

    static const type_type_ type;

    // start
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    start_type_;

    static const start_type_ start;

    // end
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    end_type_;

    static const end_type_ end;

    // flow
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    flow_type_;

    static const flow_type_ flow;

    // time
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    time_type_;

    static const time_type_ time;

    // out_link
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    out_link_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::pio::Link,
        out_link_alias_ > >
    out_link_pointer_type_;

    struct out_link_type_: out_link_pointer_type_, out_link_column_type_
    {
      out_link_type_ ()
      {
      }

      out_link_type_ (const char* t, const char* c, const char* conv)
        : out_link_column_type_ (t, c, conv)
      {
      }
    };

    static const out_link_type_ out_link;

    // out_flow
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    out_flow_type_;

    static const out_flow_type_ out_flow;

    // out_time
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    out_time_type_;

    static const out_time_type_ out_time;
  };

  template <typename A>
  const typename query_columns< ::pio::Link_Delay, A >::auto_id_type_
  query_columns< ::pio::Link_Delay, A >::
  auto_id (A::table_name, "\"auto_id\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Link_Delay, A >::link_type_
  query_columns< ::pio::Link_Delay, A >::
  link (A::table_name, "\"link\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Link_Delay, A >::dir_type_
  query_columns< ::pio::Link_Delay, A >::
  dir (A::table_name, "\"dir\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Link_Delay, A >::type_type_
  query_columns< ::pio::Link_Delay, A >::
  type (A::table_name, "\"type\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Link_Delay, A >::start_type_
  query_columns< ::pio::Link_Delay, A >::
  start (A::table_name, "\"start\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Link_Delay, A >::end_type_
  query_columns< ::pio::Link_Delay, A >::
  end (A::table_name, "\"end\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Link_Delay, A >::flow_type_
  query_columns< ::pio::Link_Delay, A >::
  flow (A::table_name, "\"flow\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Link_Delay, A >::time_type_
  query_columns< ::pio::Link_Delay, A >::
  time (A::table_name, "\"time\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Link_Delay, A >::out_link_type_
  query_columns< ::pio::Link_Delay, A >::
  out_link (A::table_name, "\"out_link\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Link_Delay, A >::out_flow_type_
  query_columns< ::pio::Link_Delay, A >::
  out_flow (A::table_name, "\"out_flow\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Link_Delay, A >::out_time_type_
  query_columns< ::pio::Link_Delay, A >::
  out_time (A::table_name, "\"out_time\"", 0);

  // Ridership
  //
  template <>
  struct query_columns_base< ::pio::Ridership >
  {
    // stop
    //
    typedef
    odb::alias_traits< ::pio::Stop, stop_alias_tag >
    stop_alias_;
  };

  template <typename A>
  struct query_columns< ::pio::Ridership, A >:
    query_columns_base< ::pio::Ridership >
  {
    // auto_id
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        long unsigned int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    auto_id_type_;

    static const auto_id_type_ auto_id;

    // mode
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    mode_type_;

    static const mode_type_ mode;

    // route
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    route_type_;

    static const route_type_ route;

    // run
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    run_type_;

    static const run_type_ run;

    // stop
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    stop_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::pio::Stop,
        stop_alias_ > >
    stop_pointer_type_;

    struct stop_type_: stop_pointer_type_, stop_column_type_
    {
      stop_type_ ()
      {
      }

      stop_type_ (const char* t, const char* c, const char* conv)
        : stop_column_type_ (t, c, conv)
      {
      }
    };

    static const stop_type_ stop;

    // schedule
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    schedule_type_;

    static const schedule_type_ schedule;

    // time
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    time_type_;

    static const time_type_ time;

    // board
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    board_type_;

    static const board_type_ board;

    // alight
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    alight_type_;

    static const alight_type_ alight;

    // load
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    load_type_;

    static const load_type_ load;

    // factor
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    factor_type_;

    static const factor_type_ factor;
  };

  template <typename A>
  const typename query_columns< ::pio::Ridership, A >::auto_id_type_
  query_columns< ::pio::Ridership, A >::
  auto_id (A::table_name, "\"auto_id\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Ridership, A >::mode_type_
  query_columns< ::pio::Ridership, A >::
  mode (A::table_name, "\"mode\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Ridership, A >::route_type_
  query_columns< ::pio::Ridership, A >::
  route (A::table_name, "\"route\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Ridership, A >::run_type_
  query_columns< ::pio::Ridership, A >::
  run (A::table_name, "\"run\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Ridership, A >::stop_type_
  query_columns< ::pio::Ridership, A >::
  stop (A::table_name, "\"stop\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Ridership, A >::schedule_type_
  query_columns< ::pio::Ridership, A >::
  schedule (A::table_name, "\"schedule\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Ridership, A >::time_type_
  query_columns< ::pio::Ridership, A >::
  time (A::table_name, "\"time\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Ridership, A >::board_type_
  query_columns< ::pio::Ridership, A >::
  board (A::table_name, "\"board\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Ridership, A >::alight_type_
  query_columns< ::pio::Ridership, A >::
  alight (A::table_name, "\"alight\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Ridership, A >::load_type_
  query_columns< ::pio::Ridership, A >::
  load (A::table_name, "\"load\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Ridership, A >::factor_type_
  query_columns< ::pio::Ridership, A >::
  factor (A::table_name, "\"factor\"", 0);

  // Vehicle
  //
  class parking_alias_tag;

#ifndef ODB_ALIAS_TRAITS_PARKING_FOR_PIO_PARKING
#define ODB_ALIAS_TRAITS_PARKING_FOR_PIO_PARKING
  template <bool d>
  struct alias_traits< ::pio::Parking, parking_alias_tag, d >
  {
    static const char table_name[];
  };

  template <bool d>
  const char alias_traits< ::pio::Parking, parking_alias_tag, d >::
  table_name[] = "\"parking\"";
#endif // ODB_ALIAS_TRAITS_PARKING_FOR_PIO_PARKING

  class type_alias_tag;

#ifndef ODB_ALIAS_TRAITS_TYPE_FOR_PIO_VEH_TYPE
#define ODB_ALIAS_TRAITS_TYPE_FOR_PIO_VEH_TYPE
  template <bool d>
  struct alias_traits< ::pio::Veh_Type, type_alias_tag, d >
  {
    static const char table_name[];
  };

  template <bool d>
  const char alias_traits< ::pio::Veh_Type, type_alias_tag, d >::
  table_name[] = "\"type\"";
#endif // ODB_ALIAS_TRAITS_TYPE_FOR_PIO_VEH_TYPE

  template <>
  struct query_columns_base< ::pio::Vehicle >
  {
    // parking
    //
    typedef
    odb::alias_traits< ::pio::Parking, parking_alias_tag >
    parking_alias_;

    // type
    //
    typedef
    odb::alias_traits< ::pio::Veh_Type, type_alias_tag >
    type_alias_;
  };

  template <typename A>
  struct query_columns< ::pio::Vehicle, A >:
    query_columns_base< ::pio::Vehicle >
  {
    // auto_id
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        long unsigned int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    auto_id_type_;

    static const auto_id_type_ auto_id;

    // hhold
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    hhold_type_;

    static const hhold_type_ hhold;

    // vehicle
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    vehicle_type_;

    static const vehicle_type_ vehicle;

    // parking
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    parking_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::pio::Parking,
        parking_alias_ > >
    parking_pointer_type_;

    struct parking_type_: parking_pointer_type_, parking_column_type_
    {
      parking_type_ ()
      {
      }

      parking_type_ (const char* t, const char* c, const char* conv)
        : parking_column_type_ (t, c, conv)
      {
      }
    };

    static const parking_type_ parking;

    // type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    type_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::pio::Veh_Type,
        type_alias_ > >
    type_pointer_type_;

    struct type_type_: type_pointer_type_, type_column_type_
    {
      type_type_ ()
      {
      }

      type_type_ (const char* t, const char* c, const char* conv)
        : type_column_type_ (t, c, conv)
      {
      }
    };

    static const type_type_ type;

    // subtype
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    subtype_type_;

    static const subtype_type_ subtype;

    // partition
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    partition_type_;

    static const partition_type_ partition;
  };

  template <typename A>
  const typename query_columns< ::pio::Vehicle, A >::auto_id_type_
  query_columns< ::pio::Vehicle, A >::
  auto_id (A::table_name, "\"auto_id\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Vehicle, A >::hhold_type_
  query_columns< ::pio::Vehicle, A >::
  hhold (A::table_name, "\"hhold\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Vehicle, A >::vehicle_type_
  query_columns< ::pio::Vehicle, A >::
  vehicle (A::table_name, "\"vehicle\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Vehicle, A >::parking_type_
  query_columns< ::pio::Vehicle, A >::
  parking (A::table_name, "\"parking\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Vehicle, A >::type_type_
  query_columns< ::pio::Vehicle, A >::
  type (A::table_name, "\"type\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Vehicle, A >::subtype_type_
  query_columns< ::pio::Vehicle, A >::
  subtype (A::table_name, "\"subtype\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Vehicle, A >::partition_type_
  query_columns< ::pio::Vehicle, A >::
  partition (A::table_name, "\"partition\"", 0);

  // Trip
  //
  class origin_alias_tag;

#ifndef ODB_ALIAS_TRAITS_ORIGIN_FOR_PIO_LOCATION
#define ODB_ALIAS_TRAITS_ORIGIN_FOR_PIO_LOCATION
  template <bool d>
  struct alias_traits< ::pio::Location, origin_alias_tag, d >
  {
    static const char table_name[];
  };

  template <bool d>
  const char alias_traits< ::pio::Location, origin_alias_tag, d >::
  table_name[] = "\"origin\"";
#endif // ODB_ALIAS_TRAITS_ORIGIN_FOR_PIO_LOCATION

  class destination_alias_tag;

#ifndef ODB_ALIAS_TRAITS_DESTINATION_FOR_PIO_LOCATION
#define ODB_ALIAS_TRAITS_DESTINATION_FOR_PIO_LOCATION
  template <bool d>
  struct alias_traits< ::pio::Location, destination_alias_tag, d >
  {
    static const char table_name[];
  };

  template <bool d>
  const char alias_traits< ::pio::Location, destination_alias_tag, d >::
  table_name[] = "\"destination\"";
#endif // ODB_ALIAS_TRAITS_DESTINATION_FOR_PIO_LOCATION

  template <>
  struct query_columns_base< ::pio::Trip >
  {
    // origin
    //
    typedef
    odb::alias_traits< ::pio::Location, origin_alias_tag >
    origin_alias_;

    // destination
    //
    typedef
    odb::alias_traits< ::pio::Location, destination_alias_tag >
    destination_alias_;
  };

  template <typename A>
  struct query_columns< ::pio::Trip, A >:
    query_columns_base< ::pio::Trip >
  {
    // auto_id
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        long unsigned int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    auto_id_type_;

    static const auto_id_type_ auto_id;

    // hhold
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    hhold_type_;

    static const hhold_type_ hhold;

    // person
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    person_type_;

    static const person_type_ person;

    // tour
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    tour_type_;

    static const tour_type_ tour;

    // trip
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    trip_type_;

    static const trip_type_ trip;

    // start
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    start_type_;

    static const start_type_ start;

    // end
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    end_type_;

    static const end_type_ end;

    // duration
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    duration_type_;

    static const duration_type_ duration;

    // origin
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    origin_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::pio::Location,
        origin_alias_ > >
    origin_pointer_type_;

    struct origin_type_: origin_pointer_type_, origin_column_type_
    {
      origin_type_ ()
      {
      }

      origin_type_ (const char* t, const char* c, const char* conv)
        : origin_column_type_ (t, c, conv)
      {
      }
    };

    static const origin_type_ origin;

    // destination
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    destination_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::pio::Location,
        destination_alias_ > >
    destination_pointer_type_;

    struct destination_type_: destination_pointer_type_, destination_column_type_
    {
      destination_type_ ()
      {
      }

      destination_type_ (const char* t, const char* c, const char* conv)
        : destination_column_type_ (t, c, conv)
      {
      }
    };

    static const destination_type_ destination;

    // purpose
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    purpose_type_;

    static const purpose_type_ purpose;

    // mode
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    mode_type_;

    static const mode_type_ mode;

    // constraint
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    constraint_type_;

    static const constraint_type_ constraint;

    // priority
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    priority_type_;

    static const priority_type_ priority;

    // vehicle
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    vehicle_type_;

    static const vehicle_type_ vehicle;

    // passengers
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    passengers_type_;

    static const passengers_type_ passengers;

    // type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    type_type_;

    static const type_type_ type;

    // partition
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    partition_type_;

    static const partition_type_ partition;
  };

  template <typename A>
  const typename query_columns< ::pio::Trip, A >::auto_id_type_
  query_columns< ::pio::Trip, A >::
  auto_id (A::table_name, "\"auto_id\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Trip, A >::hhold_type_
  query_columns< ::pio::Trip, A >::
  hhold (A::table_name, "\"hhold\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Trip, A >::person_type_
  query_columns< ::pio::Trip, A >::
  person (A::table_name, "\"person\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Trip, A >::tour_type_
  query_columns< ::pio::Trip, A >::
  tour (A::table_name, "\"tour\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Trip, A >::trip_type_
  query_columns< ::pio::Trip, A >::
  trip (A::table_name, "\"trip\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Trip, A >::start_type_
  query_columns< ::pio::Trip, A >::
  start (A::table_name, "\"start\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Trip, A >::end_type_
  query_columns< ::pio::Trip, A >::
  end (A::table_name, "\"end\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Trip, A >::duration_type_
  query_columns< ::pio::Trip, A >::
  duration (A::table_name, "\"duration\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Trip, A >::origin_type_
  query_columns< ::pio::Trip, A >::
  origin (A::table_name, "\"origin\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Trip, A >::destination_type_
  query_columns< ::pio::Trip, A >::
  destination (A::table_name, "\"destination\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Trip, A >::purpose_type_
  query_columns< ::pio::Trip, A >::
  purpose (A::table_name, "\"purpose\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Trip, A >::mode_type_
  query_columns< ::pio::Trip, A >::
  mode (A::table_name, "\"mode\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Trip, A >::constraint_type_
  query_columns< ::pio::Trip, A >::
  constraint (A::table_name, "\"constraint\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Trip, A >::priority_type_
  query_columns< ::pio::Trip, A >::
  priority (A::table_name, "\"priority\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Trip, A >::vehicle_type_
  query_columns< ::pio::Trip, A >::
  vehicle (A::table_name, "\"vehicle\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Trip, A >::passengers_type_
  query_columns< ::pio::Trip, A >::
  passengers (A::table_name, "\"passengers\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Trip, A >::type_type_
  query_columns< ::pio::Trip, A >::
  type (A::table_name, "\"type\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Trip, A >::partition_type_
  query_columns< ::pio::Trip, A >::
  partition (A::table_name, "\"partition\"", 0);

  // Problem
  //
  template <>
  struct query_columns_base< ::pio::Problem >
  {
    // link
    //
    typedef
    odb::alias_traits< ::pio::Link, link_alias_tag >
    link_alias_;
  };

  template <typename A>
  struct query_columns< ::pio::Problem, A >:
    query_columns_base< ::pio::Problem >
  {
    // problem
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    problem_type_;

    static const problem_type_ problem;

    // time
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    time_type_;

    static const time_type_ time;

    // link
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    link_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::pio::Link,
        link_alias_ > >
    link_pointer_type_;

    struct link_type_: link_pointer_type_, link_column_type_
    {
      link_type_ ()
      {
      }

      link_type_ (const char* t, const char* c, const char* conv)
        : link_column_type_ (t, c, conv)
      {
      }
    };

    static const link_type_ link;

    // dir
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    dir_type_;

    static const dir_type_ dir;

    // lane
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    lane_type_;

    static const lane_type_ lane;

    // offset
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    offset_type_;

    static const offset_type_ offset;

    // route
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    route_type_;

    static const route_type_ route;

    // survey
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    survey_type_;

    static const survey_type_ survey;
  };

  template <typename A>
  const typename query_columns< ::pio::Problem, A >::problem_type_
  query_columns< ::pio::Problem, A >::
  problem (A::table_name, "\"problem\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Problem, A >::time_type_
  query_columns< ::pio::Problem, A >::
  time (A::table_name, "\"time\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Problem, A >::link_type_
  query_columns< ::pio::Problem, A >::
  link (A::table_name, "\"link\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Problem, A >::dir_type_
  query_columns< ::pio::Problem, A >::
  dir (A::table_name, "\"dir\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Problem, A >::lane_type_
  query_columns< ::pio::Problem, A >::
  lane (A::table_name, "\"lane\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Problem, A >::offset_type_
  query_columns< ::pio::Problem, A >::
  offset (A::table_name, "\"offset\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Problem, A >::route_type_
  query_columns< ::pio::Problem, A >::
  route (A::table_name, "\"route\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Problem, A >::survey_type_
  query_columns< ::pio::Problem, A >::
  survey (A::table_name, "\"survey\"", 0);

  // Event
  //
  template <>
  struct query_columns_base< ::pio::Event >
  {
    // link
    //
    typedef
    odb::alias_traits< ::pio::Link, link_alias_tag >
    link_alias_;
  };

  template <typename A>
  struct query_columns< ::pio::Event, A >:
    query_columns_base< ::pio::Event >
  {
    // auto_id
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        long unsigned int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    auto_id_type_;

    static const auto_id_type_ auto_id;

    // hhold
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    hhold_type_;

    static const hhold_type_ hhold;

    // person
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    person_type_;

    static const person_type_ person;

    // tour
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    tour_type_;

    static const tour_type_ tour;

    // trip
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    trip_type_;

    static const trip_type_ trip;

    // mode
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    mode_type_;

    static const mode_type_ mode;

    // type
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    type_type_;

    static const type_type_ type;

    // schedule
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    schedule_type_;

    static const schedule_type_ schedule;

    // actual
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    actual_type_;

    static const actual_type_ actual;

    // link
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    link_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::pio::Link,
        link_alias_ > >
    link_pointer_type_;

    struct link_type_: link_pointer_type_, link_column_type_
    {
      link_type_ ()
      {
      }

      link_type_ (const char* t, const char* c, const char* conv)
        : link_column_type_ (t, c, conv)
      {
      }
    };

    static const link_type_ link;

    // dir
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    dir_type_;

    static const dir_type_ dir;

    // lane
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    lane_type_;

    static const lane_type_ lane;

    // offset
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    offset_type_;

    static const offset_type_ offset;

    // route
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    route_type_;

    static const route_type_ route;
  };

  template <typename A>
  const typename query_columns< ::pio::Event, A >::auto_id_type_
  query_columns< ::pio::Event, A >::
  auto_id (A::table_name, "\"auto_id\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Event, A >::hhold_type_
  query_columns< ::pio::Event, A >::
  hhold (A::table_name, "\"hhold\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Event, A >::person_type_
  query_columns< ::pio::Event, A >::
  person (A::table_name, "\"person\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Event, A >::tour_type_
  query_columns< ::pio::Event, A >::
  tour (A::table_name, "\"tour\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Event, A >::trip_type_
  query_columns< ::pio::Event, A >::
  trip (A::table_name, "\"trip\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Event, A >::mode_type_
  query_columns< ::pio::Event, A >::
  mode (A::table_name, "\"mode\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Event, A >::type_type_
  query_columns< ::pio::Event, A >::
  type (A::table_name, "\"type\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Event, A >::schedule_type_
  query_columns< ::pio::Event, A >::
  schedule (A::table_name, "\"schedule\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Event, A >::actual_type_
  query_columns< ::pio::Event, A >::
  actual (A::table_name, "\"actual\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Event, A >::link_type_
  query_columns< ::pio::Event, A >::
  link (A::table_name, "\"link\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Event, A >::dir_type_
  query_columns< ::pio::Event, A >::
  dir (A::table_name, "\"dir\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Event, A >::lane_type_
  query_columns< ::pio::Event, A >::
  lane (A::table_name, "\"lane\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Event, A >::offset_type_
  query_columns< ::pio::Event, A >::
  offset (A::table_name, "\"offset\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Event, A >::route_type_
  query_columns< ::pio::Event, A >::
  route (A::table_name, "\"route\"", 0);

  // Traveler
  //
  template <>
  struct query_columns_base< ::pio::Traveler >
  {
    // link
    //
    typedef
    odb::alias_traits< ::pio::Link, link_alias_tag >
    link_alias_;
  };

  template <typename A>
  struct query_columns< ::pio::Traveler, A >:
    query_columns_base< ::pio::Traveler >
  {
    // auto_id
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        long unsigned int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    auto_id_type_;

    static const auto_id_type_ auto_id;

    // hhold
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    hhold_type_;

    static const hhold_type_ hhold;

    // person
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    person_type_;

    static const person_type_ person;

    // tour
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    tour_type_;

    static const tour_type_ tour;

    // trip
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    trip_type_;

    static const trip_type_ trip;

    // mode
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    mode_type_;

    static const mode_type_ mode;

    // time
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    time_type_;

    static const time_type_ time;

    // distance
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    distance_type_;

    static const distance_type_ distance;

    // speed
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    speed_type_;

    static const speed_type_ speed;

    // link
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    link_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::pio::Link,
        link_alias_ > >
    link_pointer_type_;

    struct link_type_: link_pointer_type_, link_column_type_
    {
      link_type_ ()
      {
      }

      link_type_ (const char* t, const char* c, const char* conv)
        : link_column_type_ (t, c, conv)
      {
      }
    };

    static const link_type_ link;

    // dir
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    dir_type_;

    static const dir_type_ dir;

    // lane
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    lane_type_;

    static const lane_type_ lane;

    // offset
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        double,
        sqlite::id_real >::query_type,
      sqlite::id_real >
    offset_type_;

    static const offset_type_ offset;

    // route
    //
    typedef
    sqlite::query_column<
      sqlite::value_traits<
        int,
        sqlite::id_integer >::query_type,
      sqlite::id_integer >
    route_type_;

    static const route_type_ route;
  };

  template <typename A>
  const typename query_columns< ::pio::Traveler, A >::auto_id_type_
  query_columns< ::pio::Traveler, A >::
  auto_id (A::table_name, "\"auto_id\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Traveler, A >::hhold_type_
  query_columns< ::pio::Traveler, A >::
  hhold (A::table_name, "\"hhold\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Traveler, A >::person_type_
  query_columns< ::pio::Traveler, A >::
  person (A::table_name, "\"person\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Traveler, A >::tour_type_
  query_columns< ::pio::Traveler, A >::
  tour (A::table_name, "\"tour\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Traveler, A >::trip_type_
  query_columns< ::pio::Traveler, A >::
  trip (A::table_name, "\"trip\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Traveler, A >::mode_type_
  query_columns< ::pio::Traveler, A >::
  mode (A::table_name, "\"mode\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Traveler, A >::time_type_
  query_columns< ::pio::Traveler, A >::
  time (A::table_name, "\"time\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Traveler, A >::distance_type_
  query_columns< ::pio::Traveler, A >::
  distance (A::table_name, "\"distance\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Traveler, A >::speed_type_
  query_columns< ::pio::Traveler, A >::
  speed (A::table_name, "\"speed\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Traveler, A >::link_type_
  query_columns< ::pio::Traveler, A >::
  link (A::table_name, "\"link\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Traveler, A >::dir_type_
  query_columns< ::pio::Traveler, A >::
  dir (A::table_name, "\"dir\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Traveler, A >::lane_type_
  query_columns< ::pio::Traveler, A >::
  lane (A::table_name, "\"lane\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Traveler, A >::offset_type_
  query_columns< ::pio::Traveler, A >::
  offset (A::table_name, "\"offset\"", 0);

  template <typename A>
  const typename query_columns< ::pio::Traveler, A >::route_type_
  query_columns< ::pio::Traveler, A >::
  route (A::table_name, "\"route\"", 0);
}

#include "Network_IO-odb.ixx"

#include <odb/post.hxx>

#endif // INPUT_CONTEXT_ODB_HXX
